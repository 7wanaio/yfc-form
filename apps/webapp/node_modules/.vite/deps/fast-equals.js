import "./chunk-2LSFTFF7.js";

// ../../node_modules/.pnpm/fast-equals@3.0.3/node_modules/fast-equals/dist/fast-equals.esm.js
var HAS_WEAK_MAP_SUPPORT = typeof WeakMap === "function";
var keys = Object.keys;
function sameValueZeroEqual(a, b) {
  return a === b || a !== a && b !== b;
}
function isPlainObject(value) {
  return value.constructor === Object || value.constructor == null;
}
function isPromiseLike(value) {
  return !!value && typeof value.then === "function";
}
function isReactElement(value) {
  return !!(value && value.$$typeof);
}
function getNewCacheFallback() {
  var entries = [];
  return {
    delete: function(key) {
      for (var index = 0; index < entries.length; ++index) {
        if (entries[index][0] === key) {
          entries.splice(index, 1);
          return;
        }
      }
    },
    get: function(key) {
      for (var index = 0; index < entries.length; ++index) {
        if (entries[index][0] === key) {
          return entries[index][1];
        }
      }
    },
    set: function(key, value) {
      for (var index = 0; index < entries.length; ++index) {
        if (entries[index][0] === key) {
          entries[index][1] = value;
          return;
        }
      }
      entries.push([key, value]);
    }
  };
}
var getNewCache = function(canUseWeakMap) {
  if (canUseWeakMap) {
    return function _getNewCache() {
      return /* @__PURE__ */ new WeakMap();
    };
  }
  return getNewCacheFallback;
}(HAS_WEAK_MAP_SUPPORT);
function createCircularEqualCreator(isEqual) {
  return function createCircularEqual(comparator) {
    var _comparator = isEqual || comparator;
    return function circularEqual(a, b, indexOrKeyA, indexOrKeyB, parentA, parentB, cache) {
      if (cache === void 0) {
        cache = getNewCache();
      }
      var isCacheableA = !!a && typeof a === "object";
      var isCacheableB = !!b && typeof b === "object";
      if (isCacheableA !== isCacheableB) {
        return false;
      }
      if (!isCacheableA && !isCacheableB) {
        return _comparator(a, b, cache);
      }
      var cachedA = cache.get(a);
      if (cachedA && cache.get(b)) {
        return cachedA === b;
      }
      cache.set(a, b);
      cache.set(b, a);
      var result = _comparator(a, b, cache);
      cache.delete(a);
      cache.delete(b);
      return result;
    };
  };
}
function areArraysEqual(a, b, isEqual, meta) {
  var index = a.length;
  if (b.length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (!isEqual(a[index], b[index], index, index, a, b, meta)) {
      return false;
    }
  }
  return true;
}
function areMapsEqual(a, b, isEqual, meta) {
  var isValueEqual = a.size === b.size;
  if (isValueEqual && a.size) {
    var matchedIndices_1 = {};
    var indexA_1 = 0;
    a.forEach(function(aValue, aKey) {
      if (isValueEqual) {
        var hasMatch_1 = false;
        var matchIndexB_1 = 0;
        b.forEach(function(bValue, bKey) {
          if (!hasMatch_1 && !matchedIndices_1[matchIndexB_1]) {
            hasMatch_1 = isEqual(aKey, bKey, indexA_1, matchIndexB_1, a, b, meta) && isEqual(aValue, bValue, aKey, bKey, a, b, meta);
            if (hasMatch_1) {
              matchedIndices_1[matchIndexB_1] = true;
            }
          }
          matchIndexB_1++;
        });
        indexA_1++;
        isValueEqual = hasMatch_1;
      }
    });
  }
  return isValueEqual;
}
var OWNER = "_owner";
var hasOwnProperty = Function.prototype.bind.call(Function.prototype.call, Object.prototype.hasOwnProperty);
function areObjectsEqual(a, b, isEqual, meta) {
  var keysA = keys(a);
  var index = keysA.length;
  if (keys(b).length !== index) {
    return false;
  }
  if (index) {
    var key = void 0;
    while (index-- > 0) {
      key = keysA[index];
      if (key === OWNER) {
        var reactElementA = isReactElement(a);
        var reactElementB = isReactElement(b);
        if ((reactElementA || reactElementB) && reactElementA !== reactElementB) {
          return false;
        }
      }
      if (!hasOwnProperty(b, key) || !isEqual(a[key], b[key], key, key, a, b, meta)) {
        return false;
      }
    }
  }
  return true;
}
var areRegExpsEqual = function() {
  if (/foo/g.flags === "g") {
    return function areRegExpsEqual2(a, b) {
      return a.source === b.source && a.flags === b.flags;
    };
  }
  return function areRegExpsEqualFallback(a, b) {
    return a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.unicode === b.unicode && a.sticky === b.sticky && a.lastIndex === b.lastIndex;
  };
}();
function areSetsEqual(a, b, isEqual, meta) {
  var isValueEqual = a.size === b.size;
  if (isValueEqual && a.size) {
    var matchedIndices_2 = {};
    a.forEach(function(aValue, aKey) {
      if (isValueEqual) {
        var hasMatch_2 = false;
        var matchIndex_1 = 0;
        b.forEach(function(bValue, bKey) {
          if (!hasMatch_2 && !matchedIndices_2[matchIndex_1]) {
            hasMatch_2 = isEqual(aValue, bValue, aKey, bKey, a, b, meta);
            if (hasMatch_2) {
              matchedIndices_2[matchIndex_1] = true;
            }
          }
          matchIndex_1++;
        });
        isValueEqual = hasMatch_2;
      }
    });
  }
  return isValueEqual;
}
var HAS_MAP_SUPPORT = typeof Map === "function";
var HAS_SET_SUPPORT = typeof Set === "function";
var valueOf = Object.prototype.valueOf;
function createComparator(createIsEqual) {
  var isEqual = (
    /* eslint-disable no-use-before-define */
    typeof createIsEqual === "function" ? createIsEqual(comparator) : function(a, b, indexOrKeyA, indexOrKeyB, parentA, parentB, meta) {
      return comparator(a, b, meta);
    }
  );
  function comparator(a, b, meta) {
    if (a === b) {
      return true;
    }
    if (a && b && typeof a === "object" && typeof b === "object") {
      if (isPlainObject(a) && isPlainObject(b)) {
        return areObjectsEqual(a, b, isEqual, meta);
      }
      var aShape = Array.isArray(a);
      var bShape = Array.isArray(b);
      if (aShape || bShape) {
        return aShape === bShape && areArraysEqual(a, b, isEqual, meta);
      }
      aShape = a instanceof Date;
      bShape = b instanceof Date;
      if (aShape || bShape) {
        return aShape === bShape && sameValueZeroEqual(a.getTime(), b.getTime());
      }
      aShape = a instanceof RegExp;
      bShape = b instanceof RegExp;
      if (aShape || bShape) {
        return aShape === bShape && areRegExpsEqual(a, b);
      }
      if (isPromiseLike(a) || isPromiseLike(b)) {
        return a === b;
      }
      if (HAS_MAP_SUPPORT) {
        aShape = a instanceof Map;
        bShape = b instanceof Map;
        if (aShape || bShape) {
          return aShape === bShape && areMapsEqual(a, b, isEqual, meta);
        }
      }
      if (HAS_SET_SUPPORT) {
        aShape = a instanceof Set;
        bShape = b instanceof Set;
        if (aShape || bShape) {
          return aShape === bShape && areSetsEqual(a, b, isEqual, meta);
        }
      }
      if (a.valueOf !== valueOf || b.valueOf !== valueOf) {
        return sameValueZeroEqual(a.valueOf(), b.valueOf());
      }
      return areObjectsEqual(a, b, isEqual, meta);
    }
    return a !== a && b !== b;
  }
  return comparator;
}
var deepEqual = createComparator();
var shallowEqual = createComparator(function() {
  return sameValueZeroEqual;
});
var circularDeepEqual = createComparator(createCircularEqualCreator());
var circularShallowEqual = createComparator(createCircularEqualCreator(sameValueZeroEqual));
export {
  circularDeepEqual,
  circularShallowEqual,
  createComparator as createCustomEqual,
  deepEqual,
  sameValueZeroEqual,
  shallowEqual
};
//# sourceMappingURL=fast-equals.js.map
