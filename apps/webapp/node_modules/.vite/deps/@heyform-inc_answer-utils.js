import {
  parsePhoneNumber
} from "./chunk-6CGW74WG.js";
import {
  big_default
} from "./chunk-O7XFC6FG.js";
import {
  __assign,
  __read,
  __values,
  init_tslib_es6
} from "./chunk-SLCLQLWM.js";
import {
  ActionEnum,
  CHOICES_FIELD_KINDS,
  CalculateEnum,
  ComparisonEnum,
  FieldKindEnum,
  QUESTION_FIELD_KINDS,
  STATEMENT_FIELD_KINDS
} from "./chunk-3PCFUY3D.js";
import {
  helper_default,
  htmlToText
} from "./chunk-6VBUC3NS.js";
import {
  require_assertString
} from "./chunk-MOPGICVK.js";
import {
  require_dayjs_min
} from "./chunk-2IK4BMAW.js";
import {
  __commonJS,
  __toESM
} from "./chunk-2LSFTFF7.js";

// ../../node_modules/.pnpm/validator@13.11.0/node_modules/validator/lib/alpha.js
var require_alpha = __commonJS({
  "../../node_modules/.pnpm/validator@13.11.0/node_modules/validator/lib/alpha.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.commaDecimal = exports.dotDecimal = exports.bengaliLocales = exports.farsiLocales = exports.arabicLocales = exports.englishLocales = exports.decimal = exports.alphanumeric = exports.alpha = void 0;
    var alpha = {
      "en-US": /^[A-Z]+$/i,
      "az-AZ": /^[A-VXYZÇƏĞİıÖŞÜ]+$/i,
      "bg-BG": /^[А-Я]+$/i,
      "cs-CZ": /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
      "da-DK": /^[A-ZÆØÅ]+$/i,
      "de-DE": /^[A-ZÄÖÜß]+$/i,
      "el-GR": /^[Α-ώ]+$/i,
      "es-ES": /^[A-ZÁÉÍÑÓÚÜ]+$/i,
      "fa-IR": /^[ابپتثجچحخدذرزژسشصضطظعغفقکگلمنوهی]+$/i,
      "fi-FI": /^[A-ZÅÄÖ]+$/i,
      "fr-FR": /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
      "it-IT": /^[A-ZÀÉÈÌÎÓÒÙ]+$/i,
      "ja-JP": /^[ぁ-んァ-ヶｦ-ﾟ一-龠ー・。、]+$/i,
      "nb-NO": /^[A-ZÆØÅ]+$/i,
      "nl-NL": /^[A-ZÁÉËÏÓÖÜÚ]+$/i,
      "nn-NO": /^[A-ZÆØÅ]+$/i,
      "hu-HU": /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
      "pl-PL": /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
      "pt-PT": /^[A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
      "ru-RU": /^[А-ЯЁ]+$/i,
      "kk-KZ": /^[А-ЯЁ\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
      "sl-SI": /^[A-ZČĆĐŠŽ]+$/i,
      "sk-SK": /^[A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
      "sr-RS@latin": /^[A-ZČĆŽŠĐ]+$/i,
      "sr-RS": /^[А-ЯЂЈЉЊЋЏ]+$/i,
      "sv-SE": /^[A-ZÅÄÖ]+$/i,
      "th-TH": /^[ก-๐\s]+$/i,
      "tr-TR": /^[A-ZÇĞİıÖŞÜ]+$/i,
      "uk-UA": /^[А-ЩЬЮЯЄIЇҐі]+$/i,
      "vi-VN": /^[A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i,
      "ko-KR": /^[ㄱ-ㅎㅏ-ㅣ가-힣]*$/,
      "ku-IQ": /^[ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
      ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
      he: /^[א-ת]+$/,
      fa: /^['آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی']+$/i,
      bn: /^['ঀঁংঃঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহ়ঽািীুূৃৄেৈোৌ্ৎৗড়ঢ়য়ৠৡৢৣৰৱ৲৳৴৵৶৷৸৹৺৻']+$/,
      "hi-IN": /^[\u0900-\u0961]+[\u0972-\u097F]*$/i,
      "si-LK": /^[\u0D80-\u0DFF]+$/
    };
    exports.alpha = alpha;
    var alphanumeric = {
      "en-US": /^[0-9A-Z]+$/i,
      "az-AZ": /^[0-9A-VXYZÇƏĞİıÖŞÜ]+$/i,
      "bg-BG": /^[0-9А-Я]+$/i,
      "cs-CZ": /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
      "da-DK": /^[0-9A-ZÆØÅ]+$/i,
      "de-DE": /^[0-9A-ZÄÖÜß]+$/i,
      "el-GR": /^[0-9Α-ω]+$/i,
      "es-ES": /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,
      "fi-FI": /^[0-9A-ZÅÄÖ]+$/i,
      "fr-FR": /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
      "it-IT": /^[0-9A-ZÀÉÈÌÎÓÒÙ]+$/i,
      "ja-JP": /^[0-9０-９ぁ-んァ-ヶｦ-ﾟ一-龠ー・。、]+$/i,
      "hu-HU": /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
      "nb-NO": /^[0-9A-ZÆØÅ]+$/i,
      "nl-NL": /^[0-9A-ZÁÉËÏÓÖÜÚ]+$/i,
      "nn-NO": /^[0-9A-ZÆØÅ]+$/i,
      "pl-PL": /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
      "pt-PT": /^[0-9A-ZÃÁÀÂÄÇÉÊËÍÏÕÓÔÖÚÜ]+$/i,
      "ru-RU": /^[0-9А-ЯЁ]+$/i,
      "kk-KZ": /^[0-9А-ЯЁ\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
      "sl-SI": /^[0-9A-ZČĆĐŠŽ]+$/i,
      "sk-SK": /^[0-9A-ZÁČĎÉÍŇÓŠŤÚÝŽĹŔĽÄÔ]+$/i,
      "sr-RS@latin": /^[0-9A-ZČĆŽŠĐ]+$/i,
      "sr-RS": /^[0-9А-ЯЂЈЉЊЋЏ]+$/i,
      "sv-SE": /^[0-9A-ZÅÄÖ]+$/i,
      "th-TH": /^[ก-๙\s]+$/i,
      "tr-TR": /^[0-9A-ZÇĞİıÖŞÜ]+$/i,
      "uk-UA": /^[0-9А-ЩЬЮЯЄIЇҐі]+$/i,
      "ko-KR": /^[0-9ㄱ-ㅎㅏ-ㅣ가-힣]*$/,
      "ku-IQ": /^[٠١٢٣٤٥٦٧٨٩0-9ئابپتجچحخدرڕزژسشعغفڤقکگلڵمنوۆھەیێيطؤثآإأكضصةظذ]+$/i,
      "vi-VN": /^[0-9A-ZÀÁẠẢÃÂẦẤẬẨẪĂẰẮẶẲẴĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝỴỶỸ]+$/i,
      ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/,
      he: /^[0-9א-ת]+$/,
      fa: /^['0-9آاءأؤئبپتثجچحخدذرزژسشصضطظعغفقکگلمنوهةی۱۲۳۴۵۶۷۸۹۰']+$/i,
      bn: /^['ঀঁংঃঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহ়ঽািীুূৃৄেৈোৌ্ৎৗড়ঢ়য়ৠৡৢৣ০১২৩৪৫৬৭৮৯ৰৱ৲৳৴৵৶৷৸৹৺৻']+$/,
      "hi-IN": /^[\u0900-\u0963]+[\u0966-\u097F]*$/i,
      "si-LK": /^[0-9\u0D80-\u0DFF]+$/
    };
    exports.alphanumeric = alphanumeric;
    var decimal = {
      "en-US": ".",
      ar: "٫"
    };
    exports.decimal = decimal;
    var englishLocales = ["AU", "GB", "HK", "IN", "NZ", "ZA", "ZM"];
    exports.englishLocales = englishLocales;
    for (i = 0; i < englishLocales.length; i++) {
      locale = "en-".concat(englishLocales[i]);
      alpha[locale] = alpha["en-US"];
      alphanumeric[locale] = alphanumeric["en-US"];
      decimal[locale] = decimal["en-US"];
    }
    var locale;
    var i;
    var arabicLocales = ["AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE"];
    exports.arabicLocales = arabicLocales;
    for (_i = 0; _i < arabicLocales.length; _i++) {
      _locale = "ar-".concat(arabicLocales[_i]);
      alpha[_locale] = alpha.ar;
      alphanumeric[_locale] = alphanumeric.ar;
      decimal[_locale] = decimal.ar;
    }
    var _locale;
    var _i;
    var farsiLocales = ["IR", "AF"];
    exports.farsiLocales = farsiLocales;
    for (_i2 = 0; _i2 < farsiLocales.length; _i2++) {
      _locale2 = "fa-".concat(farsiLocales[_i2]);
      alphanumeric[_locale2] = alphanumeric.fa;
      decimal[_locale2] = decimal.ar;
    }
    var _locale2;
    var _i2;
    var bengaliLocales = ["BD", "IN"];
    exports.bengaliLocales = bengaliLocales;
    for (_i3 = 0; _i3 < bengaliLocales.length; _i3++) {
      _locale3 = "bn-".concat(bengaliLocales[_i3]);
      alpha[_locale3] = alpha.bn;
      alphanumeric[_locale3] = alphanumeric.bn;
      decimal[_locale3] = decimal["en-US"];
    }
    var _locale3;
    var _i3;
    var dotDecimal = ["ar-EG", "ar-LB", "ar-LY"];
    exports.dotDecimal = dotDecimal;
    var commaDecimal = ["bg-BG", "cs-CZ", "da-DK", "de-DE", "el-GR", "en-ZM", "es-ES", "fr-CA", "fr-FR", "id-ID", "it-IT", "ku-IQ", "hi-IN", "hu-HU", "nb-NO", "nn-NO", "nl-NL", "pl-PL", "pt-PT", "ru-RU", "kk-KZ", "si-LK", "sl-SI", "sr-RS@latin", "sr-RS", "sv-SE", "tr-TR", "uk-UA", "vi-VN"];
    exports.commaDecimal = commaDecimal;
    for (_i4 = 0; _i4 < dotDecimal.length; _i4++) {
      decimal[dotDecimal[_i4]] = decimal["en-US"];
    }
    var _i4;
    for (_i5 = 0; _i5 < commaDecimal.length; _i5++) {
      decimal[commaDecimal[_i5]] = ",";
    }
    var _i5;
    alpha["fr-CA"] = alpha["fr-FR"];
    alphanumeric["fr-CA"] = alphanumeric["fr-FR"];
    alpha["pt-BR"] = alpha["pt-PT"];
    alphanumeric["pt-BR"] = alphanumeric["pt-PT"];
    decimal["pt-BR"] = decimal["pt-PT"];
    alpha["pl-Pl"] = alpha["pl-PL"];
    alphanumeric["pl-Pl"] = alphanumeric["pl-PL"];
    decimal["pl-Pl"] = decimal["pl-PL"];
    alpha["fa-AF"] = alpha.fa;
  }
});

// ../../node_modules/.pnpm/validator@13.11.0/node_modules/validator/lib/isNumeric.js
var require_isNumeric = __commonJS({
  "../../node_modules/.pnpm/validator@13.11.0/node_modules/validator/lib/isNumeric.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isNumeric2;
    var _assertString = _interopRequireDefault(require_assertString());
    var _alpha = require_alpha();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var numericNoSymbols = /^[0-9]+$/;
    function isNumeric2(str, options) {
      (0, _assertString.default)(str);
      if (options && options.no_symbols) {
        return numericNoSymbols.test(str);
      }
      return new RegExp("^[+-]?([0-9]*[".concat((options || {}).locale ? _alpha.decimal[options.locale] : ".", "])?[0-9]+$")).test(str);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// ../../node_modules/.pnpm/validator@13.11.0/node_modules/validator/lib/isByteLength.js
var require_isByteLength = __commonJS({
  "../../node_modules/.pnpm/validator@13.11.0/node_modules/validator/lib/isByteLength.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isByteLength;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function isByteLength(str, options) {
      (0, _assertString.default)(str);
      var min;
      var max;
      if (_typeof(options) === "object") {
        min = options.min || 0;
        max = options.max;
      } else {
        min = arguments[1];
        max = arguments[2];
      }
      var len = encodeURI(str).split(/%..|./).length - 1;
      return len >= min && (typeof max === "undefined" || len <= max);
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// ../../node_modules/.pnpm/validator@13.11.0/node_modules/validator/lib/util/merge.js
var require_merge = __commonJS({
  "../../node_modules/.pnpm/validator@13.11.0/node_modules/validator/lib/util/merge.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = merge;
    function merge() {
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var defaults = arguments.length > 1 ? arguments[1] : void 0;
      for (var key in defaults) {
        if (typeof obj[key] === "undefined") {
          obj[key] = defaults[key];
        }
      }
      return obj;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// ../../node_modules/.pnpm/validator@13.11.0/node_modules/validator/lib/isFQDN.js
var require_isFQDN = __commonJS({
  "../../node_modules/.pnpm/validator@13.11.0/node_modules/validator/lib/isFQDN.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isFQDN;
    var _assertString = _interopRequireDefault(require_assertString());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var default_fqdn_options = {
      require_tld: true,
      allow_underscores: false,
      allow_trailing_dot: false,
      allow_numeric_tld: false,
      allow_wildcard: false,
      ignore_max_length: false
    };
    function isFQDN(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, default_fqdn_options);
      if (options.allow_trailing_dot && str[str.length - 1] === ".") {
        str = str.substring(0, str.length - 1);
      }
      if (options.allow_wildcard === true && str.indexOf("*.") === 0) {
        str = str.substring(2);
      }
      var parts = str.split(".");
      var tld = parts[parts.length - 1];
      if (options.require_tld) {
        if (parts.length < 2) {
          return false;
        }
        if (!options.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
          return false;
        }
        if (/\s/.test(tld)) {
          return false;
        }
      }
      if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
        return false;
      }
      return parts.every(function(part) {
        if (part.length > 63 && !options.ignore_max_length) {
          return false;
        }
        if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
          return false;
        }
        if (/[\uff01-\uff5e]/.test(part)) {
          return false;
        }
        if (/^-|-$/.test(part)) {
          return false;
        }
        if (!options.allow_underscores && /_/.test(part)) {
          return false;
        }
        return true;
      });
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// ../../node_modules/.pnpm/validator@13.11.0/node_modules/validator/lib/isIP.js
var require_isIP = __commonJS({
  "../../node_modules/.pnpm/validator@13.11.0/node_modules/validator/lib/isIP.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isIP;
    var _assertString = _interopRequireDefault(require_assertString());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var IPv4SegmentFormat = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
    var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
    var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
    var IPv6SegmentFormat = "(?:[0-9a-fA-F]{1,4})";
    var IPv6AddressRegExp = new RegExp("^(" + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ")(%[0-9a-zA-Z-.:]{1,})?$");
    function isIP(str) {
      var version = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      (0, _assertString.default)(str);
      version = String(version);
      if (!version) {
        return isIP(str, 4) || isIP(str, 6);
      }
      if (version === "4") {
        return IPv4AddressRegExp.test(str);
      }
      if (version === "6") {
        return IPv6AddressRegExp.test(str);
      }
      return false;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// ../../node_modules/.pnpm/validator@13.11.0/node_modules/validator/lib/isEmail.js
var require_isEmail = __commonJS({
  "../../node_modules/.pnpm/validator@13.11.0/node_modules/validator/lib/isEmail.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isEmail;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isByteLength = _interopRequireDefault(require_isByteLength());
    var _isFQDN = _interopRequireDefault(require_isFQDN());
    var _isIP = _interopRequireDefault(require_isIP());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var default_email_options = {
      allow_display_name: false,
      allow_underscores: false,
      require_display_name: false,
      allow_utf8_local_part: true,
      require_tld: true,
      blacklisted_chars: "",
      ignore_max_length: false,
      host_blacklist: [],
      host_whitelist: []
    };
    var splitNameAddress = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i;
    var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
    var gmailUserPart = /^[a-z\d]+$/;
    var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
    var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A1-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
    var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
    var defaultMaxEmailLength = 254;
    function validateDisplayName(display_name) {
      var display_name_without_quotes = display_name.replace(/^"(.+)"$/, "$1");
      if (!display_name_without_quotes.trim()) {
        return false;
      }
      var contains_illegal = /[\.";<>]/.test(display_name_without_quotes);
      if (contains_illegal) {
        if (display_name_without_quotes === display_name) {
          return false;
        }
        var all_start_with_back_slash = display_name_without_quotes.split('"').length === display_name_without_quotes.split('\\"').length;
        if (!all_start_with_back_slash) {
          return false;
        }
      }
      return true;
    }
    function isEmail(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, default_email_options);
      if (options.require_display_name || options.allow_display_name) {
        var display_email = str.match(splitNameAddress);
        if (display_email) {
          var display_name = display_email[1];
          str = str.replace(display_name, "").replace(/(^<|>$)/g, "");
          if (display_name.endsWith(" ")) {
            display_name = display_name.slice(0, -1);
          }
          if (!validateDisplayName(display_name)) {
            return false;
          }
        } else if (options.require_display_name) {
          return false;
        }
      }
      if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {
        return false;
      }
      var parts = str.split("@");
      var domain = parts.pop();
      var lower_domain = domain.toLowerCase();
      if (options.host_blacklist.includes(lower_domain)) {
        return false;
      }
      if (options.host_whitelist.length > 0 && !options.host_whitelist.includes(lower_domain)) {
        return false;
      }
      var user = parts.join("@");
      if (options.domain_specific_validation && (lower_domain === "gmail.com" || lower_domain === "googlemail.com")) {
        user = user.toLowerCase();
        var username = user.split("+")[0];
        if (!(0, _isByteLength.default)(username.replace(/\./g, ""), {
          min: 6,
          max: 30
        })) {
          return false;
        }
        var _user_parts = username.split(".");
        for (var i = 0; i < _user_parts.length; i++) {
          if (!gmailUserPart.test(_user_parts[i])) {
            return false;
          }
        }
      }
      if (options.ignore_max_length === false && (!(0, _isByteLength.default)(user, {
        max: 64
      }) || !(0, _isByteLength.default)(domain, {
        max: 254
      }))) {
        return false;
      }
      if (!(0, _isFQDN.default)(domain, {
        require_tld: options.require_tld,
        ignore_max_length: options.ignore_max_length,
        allow_underscores: options.allow_underscores
      })) {
        if (!options.allow_ip_domain) {
          return false;
        }
        if (!(0, _isIP.default)(domain)) {
          if (!domain.startsWith("[") || !domain.endsWith("]")) {
            return false;
          }
          var noBracketdomain = domain.slice(1, -1);
          if (noBracketdomain.length === 0 || !(0, _isIP.default)(noBracketdomain)) {
            return false;
          }
        }
      }
      if (user[0] === '"') {
        user = user.slice(1, user.length - 1);
        return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
      }
      var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
      var user_parts = user.split(".");
      for (var _i = 0; _i < user_parts.length; _i++) {
        if (!pattern.test(user_parts[_i])) {
          return false;
        }
      }
      if (options.blacklisted_chars) {
        if (user.search(new RegExp("[".concat(options.blacklisted_chars, "]+"), "g")) !== -1)
          return false;
      }
      return true;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// ../../node_modules/.pnpm/validator@13.11.0/node_modules/validator/lib/isURL.js
var require_isURL = __commonJS({
  "../../node_modules/.pnpm/validator@13.11.0/node_modules/validator/lib/isURL.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isURL;
    var _assertString = _interopRequireDefault(require_assertString());
    var _isFQDN = _interopRequireDefault(require_isFQDN());
    var _isIP = _interopRequireDefault(require_isIP());
    var _merge = _interopRequireDefault(require_merge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    var default_url_options = {
      protocols: ["http", "https", "ftp"],
      require_tld: true,
      require_protocol: false,
      require_host: true,
      require_port: false,
      require_valid_protocol: true,
      allow_underscores: false,
      allow_trailing_dot: false,
      allow_protocol_relative_urls: false,
      allow_fragments: true,
      allow_query_components: true,
      validate_length: true
    };
    var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
    function isRegExp(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    function checkHost(host, matches) {
      for (var i = 0; i < matches.length; i++) {
        var match = matches[i];
        if (host === match || isRegExp(match) && match.test(host)) {
          return true;
        }
      }
      return false;
    }
    function isURL(url, options) {
      (0, _assertString.default)(url);
      if (!url || /[\s<>]/.test(url)) {
        return false;
      }
      if (url.indexOf("mailto:") === 0) {
        return false;
      }
      options = (0, _merge.default)(options, default_url_options);
      if (options.validate_length && url.length >= 2083) {
        return false;
      }
      if (!options.allow_fragments && url.includes("#")) {
        return false;
      }
      if (!options.allow_query_components && (url.includes("?") || url.includes("&"))) {
        return false;
      }
      var protocol, auth, host, hostname, port, port_str, split, ipv6;
      split = url.split("#");
      url = split.shift();
      split = url.split("?");
      url = split.shift();
      split = url.split("://");
      if (split.length > 1) {
        protocol = split.shift().toLowerCase();
        if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
          return false;
        }
      } else if (options.require_protocol) {
        return false;
      } else if (url.slice(0, 2) === "//") {
        if (!options.allow_protocol_relative_urls) {
          return false;
        }
        split[0] = url.slice(2);
      }
      url = split.join("://");
      if (url === "") {
        return false;
      }
      split = url.split("/");
      url = split.shift();
      if (url === "" && !options.require_host) {
        return true;
      }
      split = url.split("@");
      if (split.length > 1) {
        if (options.disallow_auth) {
          return false;
        }
        if (split[0] === "") {
          return false;
        }
        auth = split.shift();
        if (auth.indexOf(":") >= 0 && auth.split(":").length > 2) {
          return false;
        }
        var _auth$split = auth.split(":"), _auth$split2 = _slicedToArray(_auth$split, 2), user = _auth$split2[0], password = _auth$split2[1];
        if (user === "" && password === "") {
          return false;
        }
      }
      hostname = split.join("@");
      port_str = null;
      ipv6 = null;
      var ipv6_match = hostname.match(wrapped_ipv6);
      if (ipv6_match) {
        host = "";
        ipv6 = ipv6_match[1];
        port_str = ipv6_match[2] || null;
      } else {
        split = hostname.split(":");
        host = split.shift();
        if (split.length) {
          port_str = split.join(":");
        }
      }
      if (port_str !== null && port_str.length > 0) {
        port = parseInt(port_str, 10);
        if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
          return false;
        }
      } else if (options.require_port) {
        return false;
      }
      if (options.host_whitelist) {
        return checkHost(host, options.host_whitelist);
      }
      if (host === "" && !options.require_host) {
        return true;
      }
      if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
        return false;
      }
      host = host || ipv6;
      if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
        return false;
      }
      return true;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// ../../node_modules/.pnpm/@heyform-inc+answer-utils@1.0.4_@heyform-inc+shared-types-enums@1.0.4_@heyform-inc+utils@1.0._jxjvg7mc33t22ct4hzefzwwnpi/node_modules/@heyform-inc/answer-utils/dist/index.mjs
var import_dayjs = __toESM(require_dayjs_min(), 1);
var import_isNumeric = __toESM(require_isNumeric(), 1);
var import_isEmail = __toESM(require_isEmail(), 1);
var import_isEmail2 = __toESM(require_isEmail(), 1);
var import_isURL = __toESM(require_isURL(), 1);
var import_isURL2 = __toESM(require_isURL(), 1);

// ../../node_modules/.pnpm/html5parser@2.0.2/node_modules/html5parser/dist/html5parser.es.js
init_tslib_es6();
var SyntaxKind;
(function(SyntaxKind2) {
  SyntaxKind2["Text"] = "Text";
  SyntaxKind2["Tag"] = "Tag";
})(SyntaxKind || (SyntaxKind = {}));
var state;
var buffer$1;
var bufSize;
var sectionStart;
var index$1;
var tokens$1;
var char;
var inScript;
var inStyle;
var offset;
function makeCodePoints(input) {
  return {
    lower: input.toLowerCase().split("").map(function(c) {
      return c.charCodeAt(0);
    }),
    upper: input.toUpperCase().split("").map(function(c) {
      return c.charCodeAt(0);
    }),
    length: input.length
  };
}
var doctype = makeCodePoints("!doctype");
var style = makeCodePoints("style");
var script = makeCodePoints("script");
function isWhiteSpace() {
  return char === 32 || char === 10 || char === 9 || char === 9 || char === 13 || char === 12;
}
function init$1(input) {
  state = 0;
  buffer$1 = input;
  bufSize = input.length;
  sectionStart = 0;
  index$1 = 0;
  tokens$1 = [];
  inScript = false;
  inStyle = false;
  offset = 0;
}
function tokenize(input) {
  init$1(input);
  while (index$1 < bufSize) {
    char = buffer$1.charCodeAt(index$1);
    switch (state) {
      case 0:
        parseLiteral();
        break;
      case 1:
        parseBeforeOpenTag();
        break;
      case 2:
        parseOpeningTag();
        break;
      case 3:
        parseAfterOpenTag();
        break;
      case 4:
        parseInValueNq();
        break;
      case 5:
        parseInValueSq();
        break;
      case 6:
        parseInValueDq();
        break;
      case 7:
        parseClosingOpenTag();
        break;
      case 8:
        parseOpeningSpecial();
        break;
      case 9:
        parseOpeningDoctype();
        break;
      case 10:
        parseOpeningNormalComment();
        break;
      case 11:
        parseNormalComment();
        break;
      case 12:
        parseShortComment();
        break;
      case 13:
        parseClosingNormalComment();
        break;
      case 14:
        parseClosingTag();
        break;
      default:
        unexpected$1();
        break;
    }
    index$1++;
  }
  switch (state) {
    case 0:
    case 1:
    case 4:
    case 5:
    case 6:
    case 7:
    case 11:
    case 12:
    case 13:
      emitToken(
        0
        /* Literal */
      );
      break;
    case 2:
      emitToken(
        1
        /* OpenTag */
      );
      break;
    case 3:
      break;
    case 8:
      emitToken(
        1,
        12
        /* InShortComment */
      );
      break;
    case 9:
      if (index$1 - sectionStart === doctype.length) {
        emitToken(
          1
          /* OpenTag */
        );
      } else {
        emitToken(1, void 0, sectionStart + 1);
        emitToken(
          0
          /* Literal */
        );
      }
      break;
    case 10:
      if (index$1 - sectionStart === 2) {
        emitToken(
          1
          /* OpenTag */
        );
      } else {
        emitToken(1, void 0, sectionStart + 1);
        emitToken(
          0
          /* Literal */
        );
      }
      break;
    case 14:
      emitToken(
        3
        /* CloseTag */
      );
      break;
  }
  var _tokens = tokens$1;
  init$1("");
  return _tokens;
}
function emitToken(kind, newState, end) {
  if (newState === void 0) {
    newState = state;
  }
  if (end === void 0) {
    end = index$1;
  }
  var value = buffer$1.substring(sectionStart, end);
  if (kind === 1 || kind === 3) {
    value = value.toLowerCase();
  }
  if (kind === 1) {
    if (value === "script") {
      inScript = true;
    } else if (value === "style") {
      inStyle = true;
    }
  }
  if (kind === 3) {
    inScript = inStyle = false;
  }
  if (!((kind === 0 || kind === 4) && end === sectionStart)) {
    tokens$1.push({ type: kind, start: sectionStart, end, value });
  }
  if (kind === 2 || kind === 3) {
    sectionStart = end + 1;
    state = 0;
  } else {
    sectionStart = end;
    state = newState;
  }
}
function parseLiteral() {
  if (char === 60) {
    emitToken(
      0,
      1
      /* BeforeOpenTag */
    );
  }
}
function parseBeforeOpenTag() {
  if (inScript || inStyle) {
    if (char === 47) {
      state = 14;
      sectionStart = index$1 + 1;
    } else {
      state = 0;
    }
    return;
  }
  if (char >= 97 && char <= 122 || char >= 65 && char <= 90) {
    state = 2;
    sectionStart = index$1;
  } else if (char === 47) {
    state = 14;
    sectionStart = index$1 + 1;
  } else if (char === 60) {
    emitToken(
      0
      /* Literal */
    );
  } else if (char === 33) {
    state = 8;
    sectionStart = index$1;
  } else if (char === 63) {
    sectionStart = index$1;
    emitToken(
      1,
      12
      /* InShortComment */
    );
  } else {
    state = 0;
  }
}
function parseOpeningTag() {
  if (isWhiteSpace()) {
    emitToken(
      1,
      3
      /* AfterOpenTag */
    );
  } else if (char === 62) {
    emitToken(
      1
      /* OpenTag */
    );
    emitToken(
      2
      /* OpenTagEnd */
    );
  } else if (char === 47) {
    emitToken(
      1,
      7
      /* ClosingOpenTag */
    );
  }
}
function parseAfterOpenTag() {
  if (char === 62) {
    emitToken(
      4
      /* Whitespace */
    );
    emitToken(
      2
      /* OpenTagEnd */
    );
  } else if (char === 47) {
    emitToken(
      4,
      7
      /* ClosingOpenTag */
    );
  } else if (char === 61) {
    emitToken(
      4
      /* Whitespace */
    );
    emitToken(5, void 0, index$1 + 1);
  } else if (char === 39) {
    emitToken(
      4,
      5
      /* InValueSq */
    );
  } else if (char === 34) {
    emitToken(
      4,
      6
      /* InValueDq */
    );
  } else if (!isWhiteSpace()) {
    emitToken(
      4,
      4
      /* InValueNq */
    );
  }
}
function parseInValueNq() {
  if (char === 62) {
    emitToken(
      6
      /* AttrValueNq */
    );
    emitToken(
      2
      /* OpenTagEnd */
    );
  } else if (char === 47) {
    emitToken(
      6,
      7
      /* ClosingOpenTag */
    );
  } else if (char === 61) {
    emitToken(
      6
      /* AttrValueNq */
    );
    emitToken(5, 3, index$1 + 1);
  } else if (isWhiteSpace()) {
    emitToken(
      6,
      3
      /* AfterOpenTag */
    );
  }
}
function parseInValueSq() {
  if (char === 39) {
    emitToken(7, 3, index$1 + 1);
  }
}
function parseInValueDq() {
  if (char === 34) {
    emitToken(8, 3, index$1 + 1);
  }
}
function parseClosingOpenTag() {
  if (char === 62) {
    emitToken(
      2
      /* OpenTagEnd */
    );
  } else {
    emitToken(
      6,
      3
      /* AfterOpenTag */
    );
    parseAfterOpenTag();
  }
}
function parseOpeningSpecial() {
  switch (char) {
    case 45:
      state = 10;
      break;
    case 100:
    case 68:
      state = 9;
      break;
    default:
      emitToken(
        1,
        12
        /* InShortComment */
      );
      break;
  }
}
function parseOpeningDoctype() {
  offset = index$1 - sectionStart;
  if (offset === doctype.length) {
    if (isWhiteSpace()) {
      emitToken(
        1,
        3
        /* AfterOpenTag */
      );
    } else {
      unexpected$1();
    }
  } else if (char === 62) {
    emitToken(1, void 0, sectionStart + 1);
    emitToken(
      0
      /* Literal */
    );
    emitToken(
      2
      /* OpenTagEnd */
    );
  } else if (doctype.lower[offset] !== char && doctype.upper[offset] !== char) {
    emitToken(1, 12, sectionStart + 1);
  }
}
function parseOpeningNormalComment() {
  if (char === 45) {
    emitToken(1, 11, index$1 + 1);
  } else {
    emitToken(1, 12, sectionStart + 1);
  }
}
function parseNormalComment() {
  if (char === 45) {
    emitToken(
      0,
      13
      /* ClosingNormalComment */
    );
  }
}
function parseShortComment() {
  if (char === 62) {
    emitToken(
      0
      /* Literal */
    );
    emitToken(
      2
      /* OpenTagEnd */
    );
  }
}
function parseClosingNormalComment() {
  offset = index$1 - sectionStart;
  if (offset === 2) {
    if (char === 62) {
      emitToken(
        2
        /* OpenTagEnd */
      );
    } else if (char === 45) {
      emitToken(0, void 0, sectionStart + 1);
    } else {
      state = 11;
    }
  } else if (char !== 45) {
    state = 11;
  }
}
function parseClosingTag() {
  offset = index$1 - sectionStart;
  if (inStyle) {
    if (char === 60) {
      sectionStart -= 2;
      emitToken(
        0,
        1
        /* BeforeOpenTag */
      );
    } else if (offset < style.length) {
      if (style.lower[offset] !== char && style.upper[offset] !== char) {
        sectionStart -= 2;
        state = 0;
      }
    } else if (char === 62) {
      emitToken(
        3
        /* CloseTag */
      );
    } else if (!isWhiteSpace()) {
      sectionStart -= 2;
      state = 0;
    }
  } else if (inScript) {
    if (char === 60) {
      sectionStart -= 2;
      emitToken(
        0,
        1
        /* BeforeOpenTag */
      );
    } else if (offset < script.length) {
      if (script.lower[offset] !== char && script.upper[offset] !== char) {
        sectionStart -= 2;
        state = 0;
      }
    } else if (char === 62) {
      emitToken(
        3
        /* CloseTag */
      );
    } else if (!isWhiteSpace()) {
      sectionStart -= 2;
      state = 0;
    }
  } else if (char === 62) {
    emitToken(
      3
      /* CloseTag */
    );
  }
}
function unexpected$1() {
  throw new SyntaxError('Unexpected token "' + buffer$1.charAt(index$1) + '" at ' + index$1 + " when parse " + state);
}
function createMap(keys, value) {
  return keys.split(",").reduce(function(pre, now) {
    pre[now] = value;
    return pre;
  }, /* @__PURE__ */ Object.create(null));
}
var selfCloseTags = createMap("area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr,!doctype,,!,!--", true);
var noNestedTags = createMap("li,option,select,textarea", true);
function getLineRanges(input) {
  return input.split("\n").reduce(function(arr, line) {
    arr.push(line.length + 1 + arr[arr.length - 1]);
    return arr;
  }, [0]);
}
function getPosition(ranges, offset2) {
  var line = NaN;
  var column = NaN;
  for (var i = 1; i < ranges.length; i++) {
    if (ranges[i] > offset2) {
      line = i;
      column = offset2 - ranges[i - 1] + 1;
      break;
    }
  }
  return [line, column];
}
function visit(node2, parent, index2, options) {
  options.enter && options.enter(node2, parent, index2);
  if (node2.type === SyntaxKind.Tag && Array.isArray(node2.body)) {
    for (var i = 0; i < node2.body.length; i++) {
      visit(node2.body[i], node2, i, options);
    }
  }
  options.leave && options.leave(node2, parent, index2);
}
function walk(ast, options) {
  for (var i = 0; i < ast.length; i++) {
    visit(ast[i], void 0, i, options);
  }
}
var index;
var count;
var tokens;
var tagChain;
var nodes;
var token;
var node;
var buffer;
var lines;
var parseOptions;
function init(input, options) {
  if (input === void 0) {
    count = 0;
    tokens.length = 0;
    buffer = "";
  } else {
    tokens = tokenize(input);
    count = tokens.length;
    buffer = input;
  }
  index = 0;
  tagChain = void 0;
  nodes = [];
  token = void 0;
  node = void 0;
  lines = void 0;
  parseOptions = options;
}
function pushNode(_node) {
  if (!tagChain) {
    nodes.push(_node);
  } else if (_node.type === SyntaxKind.Tag && _node.name === tagChain.tag.name && noNestedTags[_node.name]) {
    tagChain = tagChain.parent;
    pushNode(_node);
  } else if (tagChain.tag.body) {
    tagChain.tag.end = _node.end;
    tagChain.tag.body.push(_node);
  }
}
function pushTagChain(tag) {
  tagChain = { parent: tagChain, tag };
  node = void 0;
}
function createLiteral(start, end, value) {
  if (start === void 0) {
    start = token.start;
  }
  if (end === void 0) {
    end = token.end;
  }
  if (value === void 0) {
    value = token.value;
  }
  return { start, end, value, type: SyntaxKind.Text };
}
function createTag() {
  return {
    start: token.start - 1,
    end: token.end,
    type: SyntaxKind.Tag,
    open: createLiteral(token.start - 1),
    name: token.value,
    rawName: buffer.substring(token.start, token.end),
    attributes: [],
    attributeMap: void 0,
    body: null,
    close: null
  };
}
function createAttribute() {
  return {
    start: token.start,
    end: token.end,
    name: createLiteral(),
    value: void 0
  };
}
function createAttributeValue() {
  return {
    start: token.start,
    end: token.end,
    value: token.type === 6 ? token.value : token.value.substr(1, token.value.length - 2),
    quote: token.type === 6 ? void 0 : token.type === 7 ? "'" : '"'
  };
}
function appendLiteral(_node) {
  if (_node === void 0) {
    _node = node;
  }
  _node.value += token.value;
  _node.end = token.end;
}
function unexpected() {
  if (lines === void 0) {
    lines = getLineRanges(buffer);
  }
  var _a = __read(getPosition(lines, token.start), 2), line = _a[0], column = _a[1];
  throw new Error('Unexpected token "' + token.value + "(" + token.type + ')" at [' + line + "," + column + "]" + (tagChain ? " when parsing tag: " + JSON.stringify(tagChain.tag.name) + "." : ""));
}
function buildAttributeMap(tag) {
  var e_1, _a;
  tag.attributeMap = {};
  try {
    for (var _b = __values(tag.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
      var attr = _c.value;
      tag.attributeMap[attr.name.value] = attr;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return))
        _a.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
}
function parseOpenTag() {
  var state2 = 0;
  var attr = void 0;
  var tag = createTag();
  pushNode(tag);
  if (tag.name === "" || tag.name === "!" || tag.name === "!--") {
    tag.open.value = "<" + tag.open.value;
    if (index === count) {
      return;
    } else {
      token = tokens[++index];
      if (token.type !== 2) {
        node = createLiteral();
        tag.body = [node];
        while (++index < count) {
          token = tokens[index];
          if (token.type === 2) {
            node = void 0;
            break;
          }
          appendLiteral();
        }
      }
      tag.close = createLiteral(token.start, token.end + 1, token.value + ">");
      tag.end = tag.close.end;
    }
    return;
  }
  while (++index < count) {
    token = tokens[index];
    if (token.type === 2) {
      tag.end = tag.open.end = token.end + 1;
      tag.open.value = buffer.substring(tag.open.start, tag.open.end);
      if (token.value === "" && !selfCloseTags[tag.name]) {
        tag.body = [];
        pushTagChain(tag);
      } else {
        tag.body = void 0;
      }
      break;
    } else if (state2 === 0) {
      if (token.type !== 4) {
        attr = createAttribute();
        state2 = 1;
        tag.attributes.push(attr);
      }
    } else if (state2 === 1) {
      if (token.type === 4) {
        state2 = 2;
      } else if (token.type === 5) {
        state2 = 3;
      } else {
        appendLiteral(attr.name);
      }
    } else if (state2 === 2) {
      if (token.type !== 4) {
        if (token.type === 5) {
          state2 = 3;
        } else {
          attr = createAttribute();
          state2 = 1;
          tag.attributes.push(attr);
        }
      }
    } else if (state2 === 3) {
      if (token.type !== 4) {
        attr.value = createAttributeValue();
        if (token.type === 6) {
          state2 = 4;
        } else {
          attr.end = attr.value.end;
          state2 = 0;
        }
      }
    } else {
      if (token.type === 4) {
        attr.end = attr.value.end;
        state2 = 0;
      } else {
        appendLiteral(attr.value);
      }
    }
  }
}
function parseCloseTag() {
  var _context = tagChain;
  while (true) {
    if (!_context || token.value.trim() === _context.tag.name) {
      break;
    }
    _context = _context.parent;
  }
  if (!_context) {
    return;
  }
  _context.tag.close = createLiteral(token.start - 2, token.end + 1, buffer.substring(token.start - 2, token.end + 1));
  _context.tag.end = _context.tag.close.end;
  _context = _context.parent;
  tagChain = _context;
}
function parse(input, options) {
  init(input, __assign({ setAttributeMap: false }, options));
  while (index < count) {
    token = tokens[index];
    switch (token.type) {
      case 0:
        if (!node) {
          node = createLiteral();
          pushNode(node);
        } else {
          appendLiteral(node);
        }
        break;
      case 1:
        node = void 0;
        parseOpenTag();
        break;
      case 3:
        node = void 0;
        parseCloseTag();
        break;
      default:
        unexpected();
        break;
    }
    index++;
  }
  var _nodes = nodes;
  if (parseOptions === null || parseOptions === void 0 ? void 0 : parseOptions.setAttributeMap) {
    walk(_nodes, {
      enter: function(node2) {
        if (node2.type === SyntaxKind.Tag) {
          buildAttributeMap(node2);
        }
      }
    });
  }
  init();
  return _nodes;
}

// ../../node_modules/.pnpm/@heyform-inc+answer-utils@1.0.4_@heyform-inc+shared-types-enums@1.0.4_@heyform-inc+utils@1.0._jxjvg7mc33t22ct4hzefzwwnpi/node_modules/@heyform-inc/answer-utils/dist/index.mjs
var CURRENCY_SYMBOLS = {
  EUR: "€",
  GBP: "£",
  USD: "$",
  AUD: "A$",
  CAD: "CA$",
  CHF: "CHF ",
  NOK: "NOK ",
  SEK: "SEK ",
  DKK: "DKK ",
  MXN: "MX$",
  NZD: "NZ$",
  BRL: "R$"
};
function fileUpload(answer, livePreview = false) {
  if (livePreview) {
    return {
      filename: answer.name
    };
  }
  if (helper_default.isURL(answer.value)) {
    return {
      filename: "",
      url: answer.value
    };
  }
  return {
    filename: answer.value.filename || "",
    url: answer.value.url
  };
}
function rating(answer) {
  return answer.value;
}
function singleChoice(answer) {
  var _a;
  const choice = (_a = answer.properties.choices) == null ? void 0 : _a.find((row) => row.id === answer.value);
  return choice ? choice.label : "";
}
function multipleChoice(answer) {
  var _a, _b;
  return (((_b = (_a = answer.properties) == null ? void 0 : _a.choices) == null ? void 0 : _b.filter((row) => answer.value.value.includes(row.id))) || []).map((row) => row.label).concat([answer.value.other]).filter((row) => helper_default.isValid(row)).join(", ");
}
function fullName(answer) {
  return answer.value;
}
function address(answer) {
  return [
    answer.value.address1,
    ",",
    answer.value.address2,
    answer.value.city,
    ",",
    answer.value.state,
    ",",
    answer.value.country,
    answer.value.zip
  ].filter(Boolean).join(" ");
}
function legalTerms(answer) {
  return helper_default.isTrue(answer.value) ? "Yes" : "No";
}
function dateRange(answer) {
  return [answer.value.start, answer.value.end].filter(Boolean).join(" - ");
}
function inputTable(answer) {
  var _a;
  const columns = (_a = answer.properties) == null ? void 0 : _a.tableColumns;
  if (helper_default.isValidArray(columns)) {
    const result = [];
    answer.value.forEach((values) => {
      if (helper_default.isValid(values)) {
        const row = columns.map((column) => values[column.id]).join(", ");
        result.push(row);
      }
    });
    return result.join("\n");
  }
  return "";
}
function payment(answer) {
  const value = answer.value;
  const price = big_default(value.amount).div(100).toFixed(2);
  let result = CURRENCY_SYMBOLS[value.currency] + price;
  if (helper_default.isValid(value.paymentIntentId)) {
    result = `Succeeded ${result}`;
  } else {
    result = `Incomplete ${result}`;
  }
  return result;
}
var answer_parser_default = {
  fileUpload,
  rating,
  singleChoice,
  multipleChoice,
  fullName,
  address,
  legalTerms,
  dateRange,
  inputTable,
  payment
};
function answersToHtml(answers) {
  const html = answers.map((answer) => {
    const value = parseHtmlAnswer(answer);
    return `
<li>
  <h3>${answer.title}</h3>
  <p>${value}</p>
</li>
`;
  }).join("");
  return `<ol>${html}</ol>`;
}
function parseHtmlAnswer(answer) {
  var _a;
  let value = "";
  if (QUESTION_FIELD_KINDS.includes(answer.kind)) {
    switch (answer.kind) {
      case FieldKindEnum.FILE_UPLOAD:
        const file = answer_parser_default.fileUpload(answer);
        value = `${file.filename} (${file.url})`;
        break;
      case FieldKindEnum.RATING:
      case FieldKindEnum.OPINION_SCALE:
        value = answer_parser_default.rating(answer);
        break;
      case FieldKindEnum.YES_NO:
        value = answer_parser_default.singleChoice(answer);
        break;
      case FieldKindEnum.MULTIPLE_CHOICE:
      case FieldKindEnum.PICTURE_CHOICE:
        value = answer_parser_default.multipleChoice(answer);
        break;
      case FieldKindEnum.FULL_NAME:
        const name = answer_parser_default.fullName(answer);
        value = `${name.firstName} ${name.lastName}`;
        break;
      case FieldKindEnum.ADDRESS:
        value = answer_parser_default.address(answer);
        break;
      case FieldKindEnum.LEGAL_TERMS:
        value = answer_parser_default.legalTerms(answer);
        break;
      case FieldKindEnum.DATE_RANGE:
        value = answer_parser_default.dateRange(answer);
        break;
      case FieldKindEnum.INPUT_TABLE:
        value = answer_parser_default.inputTable(answer);
        break;
      case FieldKindEnum.PAYMENT:
        value = answer_parser_default.payment(answer);
        break;
      default:
        value = (_a = answer.value) == null ? void 0 : _a.toString();
    }
  }
  return value;
}
function answersToPlain(answers) {
  return answers.map((answer) => {
    const value = parsePlainAnswer(answer);
    return `${answer.title}
${value}`;
  }).join("\n\n");
}
function parsePlainAnswer(answer, livePreview = false) {
  var _a;
  let value;
  switch (answer.kind) {
    case FieldKindEnum.FILE_UPLOAD:
      const file = answer_parser_default.fileUpload(answer, livePreview);
      value = livePreview ? file.filename : `${file.filename} (${file.url})`;
      break;
    case FieldKindEnum.RATING:
    case FieldKindEnum.OPINION_SCALE:
      value = answer_parser_default.rating(answer);
      break;
    case FieldKindEnum.YES_NO:
      value = answer_parser_default.singleChoice(answer);
      break;
    case FieldKindEnum.MULTIPLE_CHOICE:
    case FieldKindEnum.PICTURE_CHOICE:
      value = answer_parser_default.multipleChoice(answer);
      break;
    case FieldKindEnum.FULL_NAME:
      const name = answer_parser_default.fullName(answer);
      value = `${name.firstName} ${name.lastName}`;
      break;
    case FieldKindEnum.ADDRESS:
      value = answer_parser_default.address(answer);
      break;
    case FieldKindEnum.LEGAL_TERMS:
      value = answer_parser_default.legalTerms(answer);
      break;
    case FieldKindEnum.DATE_RANGE:
      value = answer_parser_default.dateRange(answer);
      break;
    case FieldKindEnum.INPUT_TABLE:
      value = answer_parser_default.inputTable(answer);
      break;
    case FieldKindEnum.PAYMENT:
      value = answer_parser_default.payment(answer);
      break;
    default:
      value = (_a = answer.value) == null ? void 0 : _a.toString();
  }
  if (livePreview && helper_default.isEmpty(value)) {
    value = "_____";
  }
  return value;
}
function answersToApiObject(answers) {
  const result = {};
  answers.forEach((answer) => {
    const key = `(ID: ${answer.id}) ${answer.title}`;
    result[key] = parsePlainAnswer(answer);
  });
  return result;
}
function answersToJson(answers, options) {
  const result = {};
  answers.forEach((answer) => {
    result[answer.id] = parseJsonAnswer(answer, options == null ? void 0 : options.plain);
  });
  return result;
}
function parseJsonAnswer(answer, plain2 = false) {
  var _a;
  let value;
  switch (answer.kind) {
    case FieldKindEnum.FILE_UPLOAD:
      value = answer_parser_default.fileUpload(answer);
      if (plain2) {
        value = `${value.filename} (${value.url})`;
      }
      break;
    case FieldKindEnum.RATING:
    case FieldKindEnum.OPINION_SCALE:
      value = answer_parser_default.rating(answer);
      break;
    case FieldKindEnum.YES_NO:
      value = answer_parser_default.singleChoice(answer);
      break;
    case FieldKindEnum.MULTIPLE_CHOICE:
    case FieldKindEnum.PICTURE_CHOICE:
      value = answer_parser_default.multipleChoice(answer);
      break;
    case FieldKindEnum.FULL_NAME:
      value = answer_parser_default.fullName(answer);
      if (plain2) {
        value = `${value.firstName} ${value.lastName}`;
      }
      break;
    case FieldKindEnum.ADDRESS:
      value = answer.value;
      if (plain2) {
        value = answer_parser_default.address(answer);
      }
      break;
    case FieldKindEnum.LEGAL_TERMS:
      value = answer_parser_default.legalTerms(answer);
      break;
    case FieldKindEnum.DATE_RANGE:
      value = answer.value;
      if (plain2) {
        value = answer_parser_default.dateRange(answer);
      }
      break;
    case FieldKindEnum.INPUT_TABLE:
      value = answer.value;
      if (plain2) {
        value = answer_parser_default.inputTable(answer);
      }
      break;
    case FieldKindEnum.PAYMENT:
      value = answer.value;
      if (plain2) {
        value = answer_parser_default.payment(answer);
      }
      break;
    default:
      value = (_a = answer.value) == null ? void 0 : _a.toString();
  }
  return value;
}
function isNumber(arg) {
  return Number.isFinite(arg);
}
function isMobilePhone(arg) {
  const phoneNumber = parsePhoneNumber(arg);
  return !!(phoneNumber == null ? void 0 : phoneNumber.isValid());
}
var REGEX_FORMAT = /\[([^\]]+)]|Y{4}|M{2}|D{2}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g;
var REGEX_NUMBERS = /(\d){1,4}/g;
function getDateFormat(format, allowTime) {
  return allowTime ? `${format} HH:mm` : format;
}
function isDate(input, format = "MM/DD/YYYY") {
  const inputArr = input.match(REGEX_NUMBERS);
  const formatArr = format.match(REGEX_FORMAT);
  if (!inputArr || !formatArr || inputArr.length !== formatArr.length) {
    return false;
  }
  const dateObject = {};
  formatArr.forEach((key, index2) => {
    dateObject[key] = Number(inputArr[index2]);
  });
  const date = new Date(
    dateObject.YYYY,
    dateObject.MM - 1,
    dateObject.DD,
    dateObject.HH || 0,
    dateObject.mm || 0
  );
  if (dateObject.HH && dateObject.mm) {
    return date.getFullYear() === +dateObject.YYYY && date.getMonth() === dateObject.MM - 1 && date.getDate() === dateObject.DD && date.getHours() === dateObject.HH && date.getMinutes() === dateObject.mm;
  }
  return date.getFullYear() === +dateObject.YYYY && date.getMonth() === dateObject.MM - 1 && date.getDate() === +dateObject.DD;
}
function isNumeric(arg, options) {
  return isNumber(arg) || helper_default.isString(arg) && (0, import_isNumeric.default)(arg, options);
}
function isEqual(arg1, arg2) {
  if (helper_default.isArray(arg1) && helper_default.isArray(arg2)) {
    return arg1.length === arg2.length && arg1.every((e) => arg2.includes(e));
  }
  return String(arg1) === String(arg2);
}
function isContains(arg1, arg2) {
  if (helper_default.isArray(arg1)) {
    return arg1.includes(String(arg2));
  }
  return String(arg1).includes(String(arg2));
}
function isStartsWith(arg1, arg2) {
  return String(arg1).startsWith(String(arg2));
}
function isEndsWith(arg1, arg2) {
  return String(arg1).endsWith(String(arg2));
}
function isGreaterThan(arg1, arg2) {
  return isNumeric(arg1) && isNumeric(arg2) && Number(arg1) > Number(arg2);
}
function isLessThan(arg1, arg2) {
  return isNumeric(arg1) && isNumeric(arg2) && Number(arg1) < Number(arg2);
}
function isGreaterOrEqualThan(arg1, arg2) {
  return isNumeric(arg1) && isNumeric(arg2) && Number(arg1) >= Number(arg2);
}
function isLessOrEqualThan(arg1, arg2) {
  return isNumeric(arg1) && isNumeric(arg2) && Number(arg1) <= Number(arg2);
}
var DEFAULT_DATE_FORMAT = "YYYY-MM-DD";
function isSameDate(value, expected, format = DEFAULT_DATE_FORMAT, allowTime = false) {
  const valueFormat = getDateFormat(format, allowTime);
  const expectedFormat = getDateFormat(DEFAULT_DATE_FORMAT, allowTime);
  return (0, import_dayjs.default)(value, valueFormat).isSame((0, import_dayjs.default)(expected, expectedFormat));
}
function isBeforeDate(value, expected, format = DEFAULT_DATE_FORMAT, allowTime = false) {
  const valueFormat = getDateFormat(format, allowTime);
  const expectedFormat = getDateFormat(DEFAULT_DATE_FORMAT, allowTime);
  return (0, import_dayjs.default)(value, valueFormat).isBefore((0, import_dayjs.default)(expected, expectedFormat));
}
function isAfterDate(value, expected, format = DEFAULT_DATE_FORMAT, allowTime = false) {
  const valueFormat = getDateFormat(format, allowTime);
  const expectedFormat = getDateFormat(DEFAULT_DATE_FORMAT, allowTime);
  return (0, import_dayjs.default)(value, valueFormat).isAfter((0, import_dayjs.default)(expected, expectedFormat));
}
var ALLOWED_BLOCK_TAGS = ["div", "h1", "h2", "h3", "p", "br"];
var ALLOWED_TAGS = [
  "text",
  "span",
  "bold",
  "strong",
  "code",
  "a",
  "b",
  "i",
  "u",
  "s",
  "mention",
  "variable"
];
var ALLOWED_ATTRIBUTES = [
  "href",
  "class",
  "data-mention",
  "data-variable",
  "contenteditable",
  "style"
];
function getAttributes(row, allowedAttributes = []) {
  const result = {};
  if (helper_default.isValidArray(row)) {
    row.forEach((a) => {
      var _a;
      const name = a.name.value.toLowerCase();
      if (allowedAttributes.includes(name)) {
        result[name] = (_a = a.value) == null ? void 0 : _a.value;
      }
    });
  }
  return result;
}
function walk2(node2, option) {
  let tag = (node2.name || node2.type).toLowerCase();
  const allowedTags = option.allowedTags.concat(option.allowedBlockTags || ALLOWED_BLOCK_TAGS);
  if (allowedTags.includes(tag)) {
    const text = node2.value;
    if (tag === "text") {
      return text;
    }
    let attributes = getAttributes(node2.attributes, option.allowedAttributes);
    if (tag === "span") {
      const mentionId = attributes["data-mention"];
      const variableId = attributes["data-variable"];
      if (helper_default.isValid(mentionId)) {
        tag = "mention";
        attributes = {
          id: mentionId
        };
      } else if (helper_default.isValid(variableId)) {
        tag = "variable";
        attributes = {
          id: variableId
        };
      }
    }
    const schema = [tag];
    if (helper_default.isValidArray(node2.body)) {
      const body = node2.body.map((child) => walk2(child, option));
      if (helper_default.isValidArray(body)) {
        schema.push(body);
      }
    }
    if (helper_default.isValid(attributes)) {
      schema.push(attributes);
    }
    return schema;
  }
}
function purge(html, option) {
  const schemas = parse2(html, option);
  return serialize(schemas, option);
}
function parse2(html, option) {
  if (helper_default.isEmpty(html)) {
    return [];
  }
  const result = parse(html);
  const customOption = {
    allowedTags: ALLOWED_TAGS,
    allowedAttributes: ALLOWED_ATTRIBUTES,
    ...option
  };
  return result.map((node2) => walk2(node2, customOption)).filter(Boolean);
}
function serialize(schemas, option) {
  if (!helper_default.isValidArray(schemas)) {
    return "";
  }
  const customOption = {
    allowedTags: ALLOWED_TAGS,
    allowedAttributes: ALLOWED_ATTRIBUTES,
    ...option
  };
  const allowedTags = customOption.allowedTags.concat(
    customOption.allowedBlockTags || ALLOWED_BLOCK_TAGS
  );
  return schemas.map((schema) => {
    if (helper_default.isString(schema)) {
      return schema;
    }
    if (!helper_default.isValidArray(schema)) {
      return "";
    }
    let [tag, body, attributes] = schema;
    if (!allowedTags.includes(tag) || // Only allows empty br node
    helper_default.isEmpty(body) && helper_default.isEmpty(attributes) && tag !== "br") {
      return "";
    }
    if (customOption.plain) {
      return serialize(body, customOption);
    }
    if (tag === "br") {
      return "<br />";
    }
    let property = "";
    if (helper_default.isValid(attributes)) {
      if (tag === "mention") {
        attributes = {
          class: "mention",
          contenteditable: "false",
          "data-mention": attributes.id
        };
      } else if (tag === "variable") {
        attributes = {
          class: "variable",
          contenteditable: "false",
          "data-variable": attributes.id
        };
      }
      property = Object.keys(attributes).filter((key) => customOption.allowedAttributes.includes(key)).map((key) => ` ${key}="${attributes[key]}"`).join("");
    }
    if (tag === "mention" || tag === "variable") {
      tag = "span";
      if (customOption.livePreview) {
        body = ["_____"];
      }
    }
    return `<${tag}${property}>${serialize(body, customOption)}</${tag}>`;
  }).join("");
}
function plain(html, limit = 0) {
  if (helper_default.isEmpty(html)) {
    return "";
  }
  const result = html.replace(/<style[^<>]*>((?!<\/).)*<\/style>/gi, "").replace(/<script[^<>]*>((?!<\/).)*<\/script>/gi, "").replace(/<[^>]+>/g, "").replace(/&nbsp;/g, " ").replace(/&quot;/g, '"').replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
  if (limit > 0) {
    let sliced = result.slice(0, limit);
    if (result.length > limit) {
      sliced += "...";
    }
    return sliced;
  }
  return result;
}
var htmlUtils = {
  parse: parse2,
  serialize,
  purge,
  plain
};
function fieldsToValidateRules(fields) {
  var _a, _b;
  let rules = [];
  for (const field of fields) {
    if (!QUESTION_FIELD_KINDS.includes(field.kind)) {
      continue;
    }
    if (field.kind === FieldKindEnum.GROUP) {
      rules = [...rules, ...(_b = ((_a = field.properties) == null ? void 0 : _a.fields) || []) == null ? void 0 : _b.map((field2) => convert(field2))];
    } else {
      rules.push(convert(field));
    }
  }
  return rules;
}
function convert(field) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
  let title = field.title || "";
  let description = field.description || "";
  if (helper_default.isValidArray(field.title)) {
    title = htmlUtils.serialize(field.title, {
      plain: true
    });
  }
  if (helper_default.isValidArray(field.description)) {
    description = htmlUtils.serialize(field.description, {
      plain: true
    });
  }
  const rule = {
    id: field.id,
    kind: field.kind,
    title,
    description,
    validations: field.validations,
    properties: field.properties
  };
  if (helper_default.isBool((_a = field.validations) == null ? void 0 : _a.required)) {
    rule.required = field.validations.required;
  }
  if (helper_default.isValid((_b = field.validations) == null ? void 0 : _b.min) && isNumeric(String((_c = field.validations) == null ? void 0 : _c.min), { no_symbols: true })) {
    rule.min = field.validations.min;
  }
  if (helper_default.isValid((_d = field.validations) == null ? void 0 : _d.max) && isNumeric(String((_e = field.validations) == null ? void 0 : _e.max), { no_symbols: true })) {
    rule.max = field.validations.max;
  }
  if (helper_default.isBool((_f = field.properties) == null ? void 0 : _f.allowMultiple)) {
    rule.allowMultiple = field.properties.allowMultiple;
  }
  if (helper_default.isBool((_g = field.properties) == null ? void 0 : _g.allowOther)) {
    rule.allowOther = field.properties.allowOther;
  }
  if (helper_default.isValidArray((_h = field.properties) == null ? void 0 : _h.choices)) {
    rule.choices = field.properties.choices.map((choice) => choice.id);
  }
  if (helper_default.isString((_i = field.properties) == null ? void 0 : _i.format)) {
    rule.format = getDateFormat(field.properties.format, (_j = field.properties) == null ? void 0 : _j.allowTime);
  }
  if (isNumeric(String((_k = field.properties) == null ? void 0 : _k.price))) {
    rule.price = field.properties.price;
  }
  if (helper_default.isValid((_l = field.properties) == null ? void 0 : _l.total) && isNumeric(String((_m = field.properties) == null ? void 0 : _m.total), { no_symbols: true })) {
    rule.total = field.properties.total;
  }
  return rule;
}
var ValidateError = class extends Error {
  constructor(response) {
    super();
    this.message = response.message;
    this.response = response;
  }
};
function validate(rule, value) {
  if (!rule.required) {
    if (helper_default.isNil(value)) {
      return;
    }
  } else {
    if (helper_default.isEmpty(value)) {
      throw new ValidateError({
        id: rule.id,
        kind: rule.kind,
        title: rule.title,
        message: "This field is required"
      });
    }
  }
  switch (rule.kind) {
    case FieldKindEnum.SHORT_TEXT:
    case FieldKindEnum.LONG_TEXT:
    case FieldKindEnum.COUNTRY:
      validateText(rule, value);
      break;
    case FieldKindEnum.NUMBER:
      validateNumber(rule, value);
      break;
    case FieldKindEnum.PHONE_NUMBER:
      validatePhoneNumber(rule, value);
      break;
    case FieldKindEnum.EMAIL:
      validateEmail(rule, value);
      break;
    case FieldKindEnum.URL:
      validateUrl(rule, value);
      break;
    case FieldKindEnum.YES_NO:
      validateSingleChoice(rule, value);
      break;
    case FieldKindEnum.MULTIPLE_CHOICE:
    case FieldKindEnum.PICTURE_CHOICE:
      validateMultipleChoice(rule, value);
      break;
    case FieldKindEnum.RATING:
    case FieldKindEnum.OPINION_SCALE:
      validateRating(rule, value);
      break;
    case FieldKindEnum.DATE:
      validateDate(rule, value);
      break;
    case FieldKindEnum.DATE_RANGE:
      validateDateRange(rule, value);
      break;
    case FieldKindEnum.FILE_UPLOAD:
      validateFile(rule, value);
      break;
    case FieldKindEnum.PAYMENT:
      validatePayment(rule, value);
      break;
    case FieldKindEnum.FULL_NAME:
      validateFullName(rule, value);
      break;
    case FieldKindEnum.ADDRESS:
      validateAddress(rule, value);
      break;
    case FieldKindEnum.LEGAL_TERMS:
      validateLegalTerms(rule, value);
      break;
    case FieldKindEnum.INPUT_TABLE:
      validateInputTable(rule, value);
      break;
    case FieldKindEnum.SIGNATURE:
      validateSignature(rule, value);
      break;
  }
}
function validateFields(fields, values) {
  const rules = fieldsToValidateRules(fields);
  for (const rule of rules) {
    validate(rule, values[rule.id]);
  }
}
function validateRequiredField(field, values) {
  const _field = {
    ...{},
    ...field,
    validations: {
      ...field.validations,
      required: true
    }
  };
  try {
    validateFields([_field], values);
    return true;
  } catch (err) {
    return false;
  }
}
function validateText(rule, value) {
  if (!helper_default.isString(value)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "This field is required"
    });
  }
  if (!validateLength(value, rule.min, rule.max)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: `The text length must be between ${rule.min} to ${rule.max}`
    });
  }
}
function validateNumber(rule, value) {
  if (!isNumeric(String(value))) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: `This field should be a number`
    });
  }
  if (!validateInt(value, rule.min, rule.max)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: `The number must be between ${rule.min} to ${rule.max}`
    });
  }
}
function validatePhoneNumber(rule, value) {
  if (!isMobilePhone(value)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "Please enter a valid mobile phone number"
    });
  }
}
function validateEmail(rule, value) {
  if (!helper_default.isString(value)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "This field is required"
    });
  }
  if (!(0, import_isEmail.default)(value)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "Please enter a valid email address"
    });
  }
}
function validateUrl(rule, value) {
  if (!helper_default.isString(value)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "This field is required"
    });
  }
  if (!(0, import_isURL.default)(value)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "Please enter a valid url"
    });
  }
}
function validateSingleChoice(rule, value) {
  if (helper_default.isEmpty(rule.choices)) {
    return;
  }
  if (!rule.choices.includes(value)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "Please choose you choice"
    });
  }
}
function validateMultipleChoice(rule, value) {
  if (helper_default.isEmpty(rule.choices)) {
    return;
  }
  if (!helper_default.isArray(value.value)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "This field is required"
    });
  }
  let isOtherExists = false;
  if (!rule.allowOther) {
    if (helper_default.isValid(value.other)) {
      throw new ValidateError({
        id: rule.id,
        kind: rule.kind,
        title: rule.title,
        message: "Other value is not allowed"
      });
    }
  } else {
    if (!(helper_default.isNil(value.other) || (isOtherExists = helper_default.isValid(value.other)))) {
      throw new ValidateError({
        id: rule.id,
        kind: rule.kind,
        title: rule.title,
        message: "Other value should not be empty"
      });
    }
  }
  if (!rule.allowMultiple) {
    if (value.value.length > 1) {
      throw new ValidateError({
        id: rule.id,
        kind: rule.kind,
        title: rule.title,
        message: "Multiple choose is not allowed"
      });
    }
    const result2 = isOtherExists ? value.value.length === 0 : rule.choices.includes(value.value[0]);
    if (!result2) {
      throw new ValidateError({
        id: rule.id,
        kind: rule.kind,
        title: rule.title,
        message: "Cannot select non-specified choices"
      });
    }
  }
  const count2 = value.value.length + (isOtherExists ? 1 : 0);
  const result = validateInt(count2, rule.min, rule.max) && value.value.filter((row) => !rule.choices.includes(row)).length < 1;
  if (!result) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "Cannot select non-specified choices"
    });
  }
}
function validateRating(rule, value) {
  if (!validateInt(value, 1, rule.total)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "Rating value must be number"
    });
  }
}
function validateDate(rule, value) {
  if (!helper_default.isString(value)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "This field is required"
    });
  }
  if (!isDate(value, rule.format)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "Please enter a valid date"
    });
  }
}
function validateDateRange(rule, value) {
  if (!helper_default.isObject(value)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "This field is required"
    });
  }
  if (!isDate(value.start, rule.format)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "Start date isn't valid"
    });
  }
  if (!isDate(value.end, rule.format)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "End date isn't valid"
    });
  }
  const start = (0, import_dayjs.default)(value.start, rule.format);
  const end = (0, import_dayjs.default)(value.end, rule.format);
  if (end.isBefore(start)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "End date must be after start date"
    });
  }
}
function validateFile(rule, value) {
  if (!helper_default.isValid(value) && helper_default.isObject(value)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "This field is required"
    });
  }
}
function validateFullName(rule, value) {
  if (helper_default.isEmpty(value.firstName)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "Please enter first name"
    });
  }
  if (helper_default.isEmpty(value.lastName)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "Please enter last name"
    });
  }
}
function validateAddress(rule, value) {
  if (helper_default.isEmpty(value.address1)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "Please enter address1"
    });
  }
  if (helper_default.isEmpty(value.city)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "Please enter city"
    });
  }
  if (helper_default.isEmpty(value.state)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "Please enter state"
    });
  }
  if (helper_default.isEmpty(value.zip)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "Please enter zip"
    });
  }
  if (helper_default.isEmpty(value.country)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "Please select country"
    });
  }
}
function validatePayment(rule, value) {
  if (helper_default.isValid(process.env.VALIDATE_CLIENT_SIDE)) {
    if (!helper_default.isValid(value.name)) {
      throw new ValidateError({
        id: rule.id,
        kind: rule.kind,
        title: rule.title,
        message: "Name on card is incomplete"
      });
    }
    if (!helper_default.isTrue(value.cardNumber)) {
      throw new ValidateError({
        id: rule.id,
        kind: rule.kind,
        title: rule.title,
        message: "Card number is incomplete"
      });
    }
    if (!helper_default.isTrue(value.cardExpiry)) {
      throw new ValidateError({
        id: rule.id,
        kind: rule.kind,
        title: rule.title,
        message: "Expiry date is incomplete"
      });
    }
    if (!helper_default.isTrue(value.cardCvc)) {
      throw new ValidateError({
        id: rule.id,
        kind: rule.kind,
        title: rule.title,
        message: "Card cvc is incomplete"
      });
    }
    return;
  }
  if (helper_default.isEmpty(value.amount) || value.amount < 0) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "Invalid payment amount"
    });
  }
  if (helper_default.isEmpty(value.currency)) {
    throw new ValidateError({
      id: rule.id,
      kind: rule.kind,
      title: rule.title,
      message: "Invalid payment currency"
    });
  }
}
function validateInt(value, min, max) {
  const int = parseInt(value);
  return (max ? int <= max : true) && int >= (min || 0);
}
function validateLength(value, min, max) {
  return (max ? value.length <= max : true) && value.length >= (min || 0);
}
function validateLegalTerms(rule, value) {
  return rule.required && helper_default.isTrue(value) || false;
}
function validateInputTable(rule, value) {
  return rule.required && helper_default.isValidArray(value) || false;
}
function validateSignature(rule, value) {
  return rule.required && helper_default.isValid(value) && value.startsWith("data:image/png;base64,") || false;
}
function fieldValuesToAnswers(fields, values, partialSubmission) {
  const rules = fieldsToValidateRules(fields);
  const answers = [];
  for (const rule of rules) {
    let value = values[rule.id];
    if (partialSubmission) {
      try {
        validate(rule, value);
        answers.push({
          id: rule.id,
          title: rule.title,
          kind: rule.kind,
          properties: rule.properties || {},
          value
        });
      } catch (_) {
      }
      continue;
    }
    validate(rule, value);
    if (helper_default.isEmpty(value)) {
      if (CHOICES_FIELD_KINDS.includes(rule.kind)) {
        value = {
          value: []
        };
      } else {
        value = "";
      }
    }
    answers.push({
      id: rule.id,
      title: rule.title,
      kind: rule.kind,
      properties: rule.properties || {},
      value
    });
  }
  return answers;
}
function flattenFields(fields, withGroup = false) {
  if (helper_default.isEmpty(fields)) {
    return [];
  }
  return fields.reduce((prev, curr) => {
    var _a, _b;
    if (curr.kind === FieldKindEnum.GROUP) {
      if (withGroup) {
        const group = {
          ...{},
          ...curr,
          properties: {
            ...curr.properties,
            fields: []
          }
        };
        return [...prev, group, ...((_a = curr.properties) == null ? void 0 : _a.fields) || []];
      }
      return [...prev, ...((_b = curr.properties) == null ? void 0 : _b.fields) || []];
    }
    return [...prev, curr];
  }, []);
}
var NO_LOGIC_FIELD_KINDS = [...STATEMENT_FIELD_KINDS, FieldKindEnum.GROUP];
function validateCondition(field, condition, values) {
  switch (field.kind) {
    case FieldKindEnum.SHORT_TEXT:
    case FieldKindEnum.LONG_TEXT:
    case FieldKindEnum.PHONE_NUMBER:
    case FieldKindEnum.EMAIL:
    case FieldKindEnum.URL:
      return validateText2(field, condition, values);
    case FieldKindEnum.MULTIPLE_CHOICE:
    case FieldKindEnum.PICTURE_CHOICE:
      return validateChoice(field, condition, values);
    case FieldKindEnum.YES_NO:
    case FieldKindEnum.LEGAL_TERMS:
      return validateBoolean(field, condition, values);
    case FieldKindEnum.DATE:
      return validateDate2(field, condition, values);
    case FieldKindEnum.NUMBER:
    case FieldKindEnum.RATING:
    case FieldKindEnum.OPINION_SCALE:
      return validateNumber2(field, condition, values);
    default:
      return validateDefault(field, condition, values);
  }
}
function validateText2(field, condition, values) {
  const value = values == null ? void 0 : values[field.id];
  const { expected } = condition;
  switch (condition.comparison) {
    case ComparisonEnum.IS:
      return isEqual(value, expected);
    case ComparisonEnum.IS_NOT:
      return !isEqual(value, expected);
    case ComparisonEnum.CONTAINS:
      return isContains(value, expected);
    case ComparisonEnum.DOES_NOT_CONTAIN:
      return !isContains(value, expected);
    case ComparisonEnum.STARTS_WITH:
      return isStartsWith(value, expected);
    case ComparisonEnum.ENDS_WITH:
      return isEndsWith(value, expected);
  }
  return false;
}
function validateChoice(field, condition, values) {
  var _a;
  return ((_a = field.properties) == null ? void 0 : _a.allowMultiple) === true ? validateMultipleChoice2(field, condition, values) : validateSingleChoice2(field, condition, values);
}
function validateSingleChoice2(field, condition, values) {
  const value = values == null ? void 0 : values[field.id];
  const { expected: rawExpected } = condition;
  const expected = helper_default.isArray(rawExpected) ? rawExpected : [rawExpected];
  switch (condition.comparison) {
    case ComparisonEnum.IS:
      return isEqual(value == null ? void 0 : value.value, expected);
    case ComparisonEnum.IS_NOT:
      return !isEqual(value == null ? void 0 : value.value, expected);
  }
  return false;
}
function validateMultipleChoice2(field, condition, values) {
  const value = values == null ? void 0 : values[field.id];
  const { expected } = condition;
  switch (condition.comparison) {
    case ComparisonEnum.IS:
      return isEqual(value == null ? void 0 : value.value, expected);
    case ComparisonEnum.IS_NOT:
      return !isEqual(value == null ? void 0 : value.value, expected);
    case ComparisonEnum.CONTAINS:
      return isContains(value == null ? void 0 : value.value, expected);
    case ComparisonEnum.DOES_NOT_CONTAIN:
      return !isContains(value == null ? void 0 : value.value, expected);
  }
  return false;
}
function validateBoolean(field, condition, values) {
  const value = values == null ? void 0 : values[field.id];
  const { expected } = condition;
  switch (condition.comparison) {
    case ComparisonEnum.IS:
      return isEqual(value, expected);
    case ComparisonEnum.IS_NOT:
      return !isEqual(value, expected);
  }
  return false;
}
function validateNumber2(field, condition, values) {
  const value = values == null ? void 0 : values[field.id];
  const { expected } = condition;
  switch (condition.comparison) {
    case ComparisonEnum.EQUAL:
      return isEqual(value, expected);
    case ComparisonEnum.NOT_EQUAL:
      return !isEqual(value, expected);
    case ComparisonEnum.GREATER_THAN:
      return isGreaterThan(value, expected);
    case ComparisonEnum.LESS_THAN:
      return isLessThan(value, expected);
    case ComparisonEnum.GREATER_OR_EQUAL_THAN:
      return isGreaterOrEqualThan(value, expected);
    case ComparisonEnum.LESS_OR_EQUAL_THAN:
      return isLessOrEqualThan(value, expected);
  }
  return false;
}
function validateDate2(field, condition, values) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const value = values == null ? void 0 : values[field.id];
  const { expected } = condition;
  switch (condition.comparison) {
    case ComparisonEnum.IS:
      return isSameDate(
        value,
        expected,
        (_a = field.properties) == null ? void 0 : _a.format,
        (_b = field.properties) == null ? void 0 : _b.allowTime
      );
    case ComparisonEnum.IS_NOT:
      return !isSameDate(
        value,
        expected,
        (_c = field.properties) == null ? void 0 : _c.format,
        (_d = field.properties) == null ? void 0 : _d.allowTime
      );
    case ComparisonEnum.IS_BEFORE:
      return isBeforeDate(
        value,
        expected,
        (_e = field.properties) == null ? void 0 : _e.format,
        (_f = field.properties) == null ? void 0 : _f.allowTime
      );
    case ComparisonEnum.IS_AFTER:
      return isAfterDate(
        value,
        expected,
        (_g = field.properties) == null ? void 0 : _g.format,
        (_h = field.properties) == null ? void 0 : _h.allowTime
      );
  }
  return false;
}
function validateDefault(field, condition, values) {
  if (NO_LOGIC_FIELD_KINDS.includes(field.kind)) {
    return false;
  }
  const value = values == null ? void 0 : values[field.id];
  switch (condition.comparison) {
    case ComparisonEnum.IS_EMPTY:
      return helper_default.isEmpty(value);
    case ComparisonEnum.IS_NOT_EMPTY:
      return !helper_default.isEmpty(value);
    default:
      return false;
  }
}
var OTHER_COMPARISONS = [ComparisonEnum.IS_EMPTY, ComparisonEnum.IS_NOT_EMPTY];
function validatePayload(payload) {
  if (!payload.action.kind || !OTHER_COMPARISONS.includes(payload.condition.comparison) && helper_default.isEmpty(payload.condition.expected)) {
    return false;
  }
  if (payload.action.kind === ActionEnum.NAVIGATE) {
    return helper_default.isValid(payload.action.fieldId);
  }
  return helper_default.isValid(payload.action.variable) && helper_default.isValid(payload.action.operator) && helper_default.isValid(payload.action.value);
}
function calculateAction(action, parameters, data, values) {
  if (helper_default.isEmpty(parameters) || helper_default.isEmpty(data) || helper_default.isNil(data[action.variable])) {
    return data || {};
  }
  const variable = parameters.find((v) => v.id === action.variable);
  let current = data[action.variable];
  switch (variable.kind) {
    case "string":
      current = calculateString(current, action, values);
      break;
    case "number":
      current = calculateNumber(current, action, values);
      break;
  }
  return {
    ...data,
    [action.variable]: current
  };
}
function calculateString(value, action, values) {
  let newValue = action.value;
  if (action.ref) {
    newValue = values == null ? void 0 : values[action.ref];
  }
  if (!helper_default.isNil(newValue)) {
    switch (action.operator) {
      case CalculateEnum.ADDITION:
        return value + newValue;
      case CalculateEnum.ASSIGNMENT:
        return newValue;
    }
  }
  return value;
}
function calculateNumber(value, action, values) {
  let newValue = action.value;
  if (action.ref) {
    newValue = values == null ? void 0 : values[action.ref];
  }
  if (!helper_default.isNil(newValue) && isNumber(newValue)) {
    switch (action.operator) {
      case CalculateEnum.ADDITION:
        return value + newValue;
      case CalculateEnum.SUBTRACTION:
        return value - newValue;
      case CalculateEnum.MULTIPLICATION:
        return value * newValue;
      case CalculateEnum.DIVISION:
        return newValue !== 0 ? value / newValue : value;
      case CalculateEnum.ASSIGNMENT:
        return newValue;
    }
  }
  return value;
}
function indexFields(fields) {
  const parents = fields.filter((f) => !f.parent && QUESTION_FIELD_KINDS.includes(f.kind));
  const children = fields.filter((f) => f.parent && QUESTION_FIELD_KINDS.includes(f.kind));
  let index2 = 1;
  const childrenIndexes = {};
  parents.forEach((f) => {
    f.index = index2++;
  });
  children.forEach((f) => {
    const parentId = f.parent.id;
    const parent = parents.find((p) => p.id === parentId);
    if (!childrenIndexes[parentId]) {
      childrenIndexes[parentId] = 1;
    }
    f.parent = parent;
    f.index = childrenIndexes[parentId]++;
  });
}
function applyLogicToFields(fields, logics, parameters, values) {
  const result = {
    fields: [],
    variables: {}
  };
  if (helper_default.isEmpty(fields)) {
    return result;
  }
  if (helper_default.isValid(parameters)) {
    for (const variable of parameters) {
      result.variables[variable.id] = variable.value;
    }
  }
  if (helper_default.isEmpty(logics) || helper_default.isEmpty(values)) {
    indexFields(fields);
    return {
      ...result,
      fields: fields.filter((f) => f.kind !== FieldKindEnum.THANK_YOU)
    };
  }
  let index2 = 0;
  while (index2 < fields.length) {
    const field = fields[index2];
    if (field.kind === FieldKindEnum.THANK_YOU) {
      break;
    }
    let isNavigateValidated = false;
    const logic = logics.find((l) => l.fieldId === field.id);
    if (field.parent && result.fields.findIndex((f) => f.id === field.parent.id) < 0) {
      result.fields.push(field.parent);
    }
    if (logic) {
      const { payloads } = logic;
      const calculates = payloads.filter((p) => p.action.kind === ActionEnum.CALCULATE);
      for (const calculate of calculates) {
        const { action, condition } = calculate;
        const isValidated = validateCondition(field, condition, values);
        if (isValidated) {
          result.variables = calculateAction(
            action,
            parameters,
            result.variables,
            values
          );
        }
      }
      const navigates = payloads.filter((p) => p.action.kind === ActionEnum.NAVIGATE);
      for (const navigate of navigates) {
        const { action, condition } = navigate;
        field.isTouched = validateCondition(field, condition, values);
        if (field.isTouched) {
          const jumpFieldId = action.fieldId;
          const jumpIndex = fields.findIndex((f) => f.id === jumpFieldId);
          const isExists = !!result.fields.find((f) => f.id === jumpFieldId);
          if (!isExists && jumpIndex > index2) {
            index2 = jumpIndex;
            isNavigateValidated = true;
            result.fields.push(field);
            break;
          }
        } else {
          field.isTouched = validateRequiredField(field, values);
        }
      }
    }
    if (!isNavigateValidated) {
      index2 += 1;
      result.fields.push(field);
    }
  }
  indexFields(result.fields);
  return result;
}
var export_isEmail = import_isEmail2.default;
var export_isURL = import_isURL2.default;
export {
  CURRENCY_SYMBOLS,
  ValidateError,
  answersToApiObject,
  answersToHtml,
  answersToJson,
  answersToPlain,
  applyLogicToFields,
  fieldValuesToAnswers,
  fieldsToValidateRules,
  flattenFields,
  getDateFormat,
  htmlToText,
  htmlUtils,
  isAfterDate,
  isBeforeDate,
  isContains,
  isDate,
  export_isEmail as isEmail,
  isEndsWith,
  isEqual,
  isGreaterOrEqualThan,
  isGreaterThan,
  isLessOrEqualThan,
  isLessThan,
  isMobilePhone,
  isNumber,
  isNumeric,
  isSameDate,
  isStartsWith,
  export_isURL as isURL,
  parsePlainAnswer,
  validate,
  validateCondition,
  validateFields,
  validatePayload,
  validateRequiredField
};
/*! Bundled license information:

html5parser/dist/html5parser.es.js:
  (*!
   *
   * Copyright 2017 - acrazing
   *
   * @author acrazing joking.young@gmail.com
   * @since 2017-08-18 15:17:51
   * @version 1.0.0
   * @desc types.ts
   *)
  (*!
   *
   * Copyright 2017 - acrazing
   *
   * @author acrazing joking.young@gmail.com
   * @since 2017-08-19 00:54:29
   * @version 1.0.0
   * @desc tokenize.ts
   *)
  (*!
   *
   * Copyright 2017 - acrazing
   *
   * @author acrazing joking.young@gmail.com
   * @since 2017-08-19 15:56:14
   * @version 1.0.0
   * @desc config.ts
   *)
  (*!
   *
   * Copyright 2017 - acrazing
   *
   * @author acrazing joking.young@gmail.com
   * @since 2017-08-20 21:41:39
   * @version 1.0.0
   * @desc utils.ts
   *)
  (*!
   *
   * Copyright 2017 - acrazing
   *
   * @author acrazing joking.young@gmail.com
   * @since 2017-08-19 00:54:46
   * @version 1.0.0
   * @desc walk.ts
   *)
  (*!
   *
   * Copyright 2017 - acrazing
   *
   * @author acrazing joking.young@gmail.com
   * @since 2017-08-19 00:54:46
   * @version 1.0.0
   * @desc parse.ts
   *)
*/
//# sourceMappingURL=@heyform-inc_answer-utils.js.map
