import {
  init_visitor
} from "./chunk-4GZRJ6XO.js";
import {
  __commonJS,
  __toESM
} from "./chunk-2LSFTFF7.js";

// ../../node_modules/.pnpm/zen-observable@0.8.15/node_modules/zen-observable/lib/Observable.js
var require_Observable = __commonJS({
  "../../node_modules/.pnpm/zen-observable@0.8.15/node_modules/zen-observable/lib/Observable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Observable = void 0;
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var hasSymbols = function() {
      return typeof Symbol === "function";
    };
    var hasSymbol = function(name) {
      return hasSymbols() && Boolean(Symbol[name]);
    };
    var getSymbol = function(name) {
      return hasSymbol(name) ? Symbol[name] : "@@" + name;
    };
    if (hasSymbols() && !hasSymbol("observable")) {
      Symbol.observable = Symbol("observable");
    }
    var SymbolIterator = getSymbol("iterator");
    var SymbolObservable = getSymbol("observable");
    var SymbolSpecies = getSymbol("species");
    function getMethod(obj, key) {
      var value = obj[key];
      if (value == null)
        return void 0;
      if (typeof value !== "function")
        throw new TypeError(value + " is not a function");
      return value;
    }
    function getSpecies(obj) {
      var ctor = obj.constructor;
      if (ctor !== void 0) {
        ctor = ctor[SymbolSpecies];
        if (ctor === null) {
          ctor = void 0;
        }
      }
      return ctor !== void 0 ? ctor : Observable2;
    }
    function isObservable(x) {
      return x instanceof Observable2;
    }
    function hostReportError(e) {
      if (hostReportError.log) {
        hostReportError.log(e);
      } else {
        setTimeout(function() {
          throw e;
        });
      }
    }
    function enqueue(fn) {
      Promise.resolve().then(function() {
        try {
          fn();
        } catch (e) {
          hostReportError(e);
        }
      });
    }
    function cleanupSubscription(subscription) {
      var cleanup = subscription._cleanup;
      if (cleanup === void 0)
        return;
      subscription._cleanup = void 0;
      if (!cleanup) {
        return;
      }
      try {
        if (typeof cleanup === "function") {
          cleanup();
        } else {
          var unsubscribe = getMethod(cleanup, "unsubscribe");
          if (unsubscribe) {
            unsubscribe.call(cleanup);
          }
        }
      } catch (e) {
        hostReportError(e);
      }
    }
    function closeSubscription(subscription) {
      subscription._observer = void 0;
      subscription._queue = void 0;
      subscription._state = "closed";
    }
    function flushSubscription(subscription) {
      var queue = subscription._queue;
      if (!queue) {
        return;
      }
      subscription._queue = void 0;
      subscription._state = "ready";
      for (var i = 0; i < queue.length; ++i) {
        notifySubscription(subscription, queue[i].type, queue[i].value);
        if (subscription._state === "closed")
          break;
      }
    }
    function notifySubscription(subscription, type, value) {
      subscription._state = "running";
      var observer = subscription._observer;
      try {
        var m = getMethod(observer, type);
        switch (type) {
          case "next":
            if (m)
              m.call(observer, value);
            break;
          case "error":
            closeSubscription(subscription);
            if (m)
              m.call(observer, value);
            else
              throw value;
            break;
          case "complete":
            closeSubscription(subscription);
            if (m)
              m.call(observer);
            break;
        }
      } catch (e) {
        hostReportError(e);
      }
      if (subscription._state === "closed")
        cleanupSubscription(subscription);
      else if (subscription._state === "running")
        subscription._state = "ready";
    }
    function onNotify(subscription, type, value) {
      if (subscription._state === "closed")
        return;
      if (subscription._state === "buffering") {
        subscription._queue.push({
          type,
          value
        });
        return;
      }
      if (subscription._state !== "ready") {
        subscription._state = "buffering";
        subscription._queue = [{
          type,
          value
        }];
        enqueue(function() {
          return flushSubscription(subscription);
        });
        return;
      }
      notifySubscription(subscription, type, value);
    }
    var Subscription = function() {
      function Subscription2(observer, subscriber) {
        _classCallCheck(this, Subscription2);
        this._cleanup = void 0;
        this._observer = observer;
        this._queue = void 0;
        this._state = "initializing";
        var subscriptionObserver = new SubscriptionObserver(this);
        try {
          this._cleanup = subscriber.call(void 0, subscriptionObserver);
        } catch (e) {
          subscriptionObserver.error(e);
        }
        if (this._state === "initializing")
          this._state = "ready";
      }
      _createClass(Subscription2, [{
        key: "unsubscribe",
        value: function unsubscribe() {
          if (this._state !== "closed") {
            closeSubscription(this);
            cleanupSubscription(this);
          }
        }
      }, {
        key: "closed",
        get: function() {
          return this._state === "closed";
        }
      }]);
      return Subscription2;
    }();
    var SubscriptionObserver = function() {
      function SubscriptionObserver2(subscription) {
        _classCallCheck(this, SubscriptionObserver2);
        this._subscription = subscription;
      }
      _createClass(SubscriptionObserver2, [{
        key: "next",
        value: function next(value) {
          onNotify(this._subscription, "next", value);
        }
      }, {
        key: "error",
        value: function error(value) {
          onNotify(this._subscription, "error", value);
        }
      }, {
        key: "complete",
        value: function complete() {
          onNotify(this._subscription, "complete");
        }
      }, {
        key: "closed",
        get: function() {
          return this._subscription._state === "closed";
        }
      }]);
      return SubscriptionObserver2;
    }();
    var Observable2 = function() {
      function Observable3(subscriber) {
        _classCallCheck(this, Observable3);
        if (!(this instanceof Observable3))
          throw new TypeError("Observable cannot be called as a function");
        if (typeof subscriber !== "function")
          throw new TypeError("Observable initializer must be a function");
        this._subscriber = subscriber;
      }
      _createClass(Observable3, [{
        key: "subscribe",
        value: function subscribe(observer) {
          if (typeof observer !== "object" || observer === null) {
            observer = {
              next: observer,
              error: arguments[1],
              complete: arguments[2]
            };
          }
          return new Subscription(observer, this._subscriber);
        }
      }, {
        key: "forEach",
        value: function forEach(fn) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            if (typeof fn !== "function") {
              reject(new TypeError(fn + " is not a function"));
              return;
            }
            function done() {
              subscription.unsubscribe();
              resolve();
            }
            var subscription = _this.subscribe({
              next: function(value) {
                try {
                  fn(value, done);
                } catch (e) {
                  reject(e);
                  subscription.unsubscribe();
                }
              },
              error: reject,
              complete: resolve
            });
          });
        }
      }, {
        key: "map",
        value: function map(fn) {
          var _this2 = this;
          if (typeof fn !== "function")
            throw new TypeError(fn + " is not a function");
          var C = getSpecies(this);
          return new C(function(observer) {
            return _this2.subscribe({
              next: function(value) {
                try {
                  value = fn(value);
                } catch (e) {
                  return observer.error(e);
                }
                observer.next(value);
              },
              error: function(e) {
                observer.error(e);
              },
              complete: function() {
                observer.complete();
              }
            });
          });
        }
      }, {
        key: "filter",
        value: function filter(fn) {
          var _this3 = this;
          if (typeof fn !== "function")
            throw new TypeError(fn + " is not a function");
          var C = getSpecies(this);
          return new C(function(observer) {
            return _this3.subscribe({
              next: function(value) {
                try {
                  if (!fn(value))
                    return;
                } catch (e) {
                  return observer.error(e);
                }
                observer.next(value);
              },
              error: function(e) {
                observer.error(e);
              },
              complete: function() {
                observer.complete();
              }
            });
          });
        }
      }, {
        key: "reduce",
        value: function reduce(fn) {
          var _this4 = this;
          if (typeof fn !== "function")
            throw new TypeError(fn + " is not a function");
          var C = getSpecies(this);
          var hasSeed = arguments.length > 1;
          var hasValue = false;
          var seed = arguments[1];
          var acc = seed;
          return new C(function(observer) {
            return _this4.subscribe({
              next: function(value) {
                var first = !hasValue;
                hasValue = true;
                if (!first || hasSeed) {
                  try {
                    acc = fn(acc, value);
                  } catch (e) {
                    return observer.error(e);
                  }
                } else {
                  acc = value;
                }
              },
              error: function(e) {
                observer.error(e);
              },
              complete: function() {
                if (!hasValue && !hasSeed)
                  return observer.error(new TypeError("Cannot reduce an empty sequence"));
                observer.next(acc);
                observer.complete();
              }
            });
          });
        }
      }, {
        key: "concat",
        value: function concat2() {
          var _this5 = this;
          for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
            sources[_key] = arguments[_key];
          }
          var C = getSpecies(this);
          return new C(function(observer) {
            var subscription;
            var index = 0;
            function startNext(next) {
              subscription = next.subscribe({
                next: function(v) {
                  observer.next(v);
                },
                error: function(e) {
                  observer.error(e);
                },
                complete: function() {
                  if (index === sources.length) {
                    subscription = void 0;
                    observer.complete();
                  } else {
                    startNext(C.from(sources[index++]));
                  }
                }
              });
            }
            startNext(_this5);
            return function() {
              if (subscription) {
                subscription.unsubscribe();
                subscription = void 0;
              }
            };
          });
        }
      }, {
        key: "flatMap",
        value: function flatMap(fn) {
          var _this6 = this;
          if (typeof fn !== "function")
            throw new TypeError(fn + " is not a function");
          var C = getSpecies(this);
          return new C(function(observer) {
            var subscriptions = [];
            var outer = _this6.subscribe({
              next: function(value) {
                if (fn) {
                  try {
                    value = fn(value);
                  } catch (e) {
                    return observer.error(e);
                  }
                }
                var inner = C.from(value).subscribe({
                  next: function(value2) {
                    observer.next(value2);
                  },
                  error: function(e) {
                    observer.error(e);
                  },
                  complete: function() {
                    var i = subscriptions.indexOf(inner);
                    if (i >= 0)
                      subscriptions.splice(i, 1);
                    completeIfDone();
                  }
                });
                subscriptions.push(inner);
              },
              error: function(e) {
                observer.error(e);
              },
              complete: function() {
                completeIfDone();
              }
            });
            function completeIfDone() {
              if (outer.closed && subscriptions.length === 0)
                observer.complete();
            }
            return function() {
              subscriptions.forEach(function(s) {
                return s.unsubscribe();
              });
              outer.unsubscribe();
            };
          });
        }
      }, {
        key: SymbolObservable,
        value: function() {
          return this;
        }
      }], [{
        key: "from",
        value: function from2(x) {
          var C = typeof this === "function" ? this : Observable3;
          if (x == null)
            throw new TypeError(x + " is not an object");
          var method = getMethod(x, SymbolObservable);
          if (method) {
            var observable = method.call(x);
            if (Object(observable) !== observable)
              throw new TypeError(observable + " is not an object");
            if (isObservable(observable) && observable.constructor === C)
              return observable;
            return new C(function(observer) {
              return observable.subscribe(observer);
            });
          }
          if (hasSymbol("iterator")) {
            method = getMethod(x, SymbolIterator);
            if (method) {
              return new C(function(observer) {
                enqueue(function() {
                  if (observer.closed)
                    return;
                  var _iteratorNormalCompletion = true;
                  var _didIteratorError = false;
                  var _iteratorError = void 0;
                  try {
                    for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                      var _item = _step.value;
                      observer.next(_item);
                      if (observer.closed)
                        return;
                    }
                  } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                      }
                    } finally {
                      if (_didIteratorError) {
                        throw _iteratorError;
                      }
                    }
                  }
                  observer.complete();
                });
              });
            }
          }
          if (Array.isArray(x)) {
            return new C(function(observer) {
              enqueue(function() {
                if (observer.closed)
                  return;
                for (var i = 0; i < x.length; ++i) {
                  observer.next(x[i]);
                  if (observer.closed)
                    return;
                }
                observer.complete();
              });
            });
          }
          throw new TypeError(x + " is not observable");
        }
      }, {
        key: "of",
        value: function of() {
          for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            items[_key2] = arguments[_key2];
          }
          var C = typeof this === "function" ? this : Observable3;
          return new C(function(observer) {
            enqueue(function() {
              if (observer.closed)
                return;
              for (var i = 0; i < items.length; ++i) {
                observer.next(items[i]);
                if (observer.closed)
                  return;
              }
              observer.complete();
            });
          });
        }
      }, {
        key: SymbolSpecies,
        get: function() {
          return this;
        }
      }]);
      return Observable3;
    }();
    exports.Observable = Observable2;
    if (hasSymbols()) {
      Object.defineProperty(Observable2, Symbol("extensions"), {
        value: {
          symbol: SymbolObservable,
          hostReportError
        },
        configurable: true
      });
    }
  }
});

// ../../node_modules/.pnpm/zen-observable@0.8.15/node_modules/zen-observable/index.js
var require_zen_observable = __commonJS({
  "../../node_modules/.pnpm/zen-observable@0.8.15/node_modules/zen-observable/index.js"(exports, module) {
    module.exports = require_Observable().Observable;
  }
});

// ../../node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "../../node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js"(exports, module) {
    "use strict";
    module.exports = function(data, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify2(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i)
              out += ",";
            out += stringify2(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify2(node[key]);
          if (!value)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data);
    };
  }
});

// ../../node_modules/.pnpm/tslib@1.14.1/node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}

// ../../node_modules/.pnpm/zen-observable-ts@0.8.21/node_modules/zen-observable-ts/lib/bundle.esm.js
var import_zen_observable = __toESM(require_zen_observable());
var Observable = import_zen_observable.default;
var bundle_esm_default = Observable;

// ../../node_modules/.pnpm/ts-invariant@0.4.4/node_modules/ts-invariant/lib/invariant.esm.js
var genericMessage = "Invariant Violation";
var _a = Object.setPrototypeOf;
var setPrototypeOf = _a === void 0 ? function(obj, proto) {
  obj.__proto__ = proto;
  return obj;
} : _a;
var InvariantError = (
  /** @class */
  function(_super) {
    __extends(InvariantError2, _super);
    function InvariantError2(message) {
      if (message === void 0) {
        message = genericMessage;
      }
      var _this = _super.call(this, typeof message === "number" ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)" : message) || this;
      _this.framesToPop = 1;
      _this.name = genericMessage;
      setPrototypeOf(_this, InvariantError2.prototype);
      return _this;
    }
    return InvariantError2;
  }(Error)
);
function invariant(condition, message) {
  if (!condition) {
    throw new InvariantError(message);
  }
}
function wrapConsoleMethod(method) {
  return function() {
    return console[method].apply(console, arguments);
  };
}
(function(invariant2) {
  invariant2.warn = wrapConsoleMethod("warn");
  invariant2.error = wrapConsoleMethod("error");
})(invariant || (invariant = {}));
var processStub = { env: {} };
if (typeof process === "object") {
  processStub = process;
} else
  try {
    Function("stub", "process = stub")(processStub);
  } catch (atLeastWeTried) {
  }

// ../../node_modules/.pnpm/apollo-utilities@1.3.4_graphql@15.3.0/node_modules/apollo-utilities/lib/bundle.esm.js
init_visitor();
var import_fast_json_stable_stringify = __toESM(require_fast_json_stable_stringify());

// ../../node_modules/.pnpm/@wry+equality@0.1.11/node_modules/@wry/equality/lib/equality.esm.js
var _a2 = Object.prototype;
var toString = _a2.toString;
var hasOwnProperty = _a2.hasOwnProperty;

// ../../node_modules/.pnpm/apollo-utilities@1.3.4_graphql@15.3.0/node_modules/apollo-utilities/lib/bundle.esm.js
function getOperationName(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition" && definition.name;
  }).map(function(x) {
    return x.name.value;
  })[0] || null;
}
var canUseWeakMap = typeof WeakMap === "function" && !(typeof navigator === "object" && navigator.product === "ReactNative");

// ../../node_modules/.pnpm/apollo-link@1.2.14_graphql@15.3.0/node_modules/apollo-link/lib/bundle.esm.js
function validateOperation(operation) {
  var OPERATION_FIELDS = [
    "query",
    "operationName",
    "variables",
    "extensions",
    "context"
  ];
  for (var _i = 0, _a3 = Object.keys(operation); _i < _a3.length; _i++) {
    var key = _a3[_i];
    if (OPERATION_FIELDS.indexOf(key) < 0) {
      throw false ? new InvariantError(2) : new InvariantError("illegal argument: " + key);
    }
  }
  return operation;
}
var LinkError = function(_super) {
  __extends(LinkError2, _super);
  function LinkError2(message, link) {
    var _this = _super.call(this, message) || this;
    _this.link = link;
    return _this;
  }
  return LinkError2;
}(Error);
function isTerminating(link) {
  return link.request.length <= 1;
}
function transformOperation(operation) {
  var transformedOperation = {
    variables: operation.variables || {},
    extensions: operation.extensions || {},
    operationName: operation.operationName,
    query: operation.query
  };
  if (!transformedOperation.operationName) {
    transformedOperation.operationName = typeof transformedOperation.query !== "string" ? getOperationName(transformedOperation.query) : "";
  }
  return transformedOperation;
}
function createOperation(starting, operation) {
  var context = __assign({}, starting);
  var setContext = function(next) {
    if (typeof next === "function") {
      context = __assign({}, context, next(context));
    } else {
      context = __assign({}, context, next);
    }
  };
  var getContext = function() {
    return __assign({}, context);
  };
  Object.defineProperty(operation, "setContext", {
    enumerable: false,
    value: setContext
  });
  Object.defineProperty(operation, "getContext", {
    enumerable: false,
    value: getContext
  });
  Object.defineProperty(operation, "toKey", {
    enumerable: false,
    value: function() {
      return getKey(operation);
    }
  });
  return operation;
}
function getKey(operation) {
  var query = operation.query, variables = operation.variables, operationName = operation.operationName;
  return JSON.stringify([operationName, query, variables]);
}
function passthrough(op, forward) {
  return forward ? forward(op) : bundle_esm_default.of();
}
function toLink(handler) {
  return typeof handler === "function" ? new ApolloLink(handler) : handler;
}
function empty() {
  return new ApolloLink(function() {
    return bundle_esm_default.of();
  });
}
function from(links) {
  if (links.length === 0)
    return empty();
  return links.map(toLink).reduce(function(x, y) {
    return x.concat(y);
  });
}
function split(test, left, right) {
  var leftLink = toLink(left);
  var rightLink = toLink(right || new ApolloLink(passthrough));
  if (isTerminating(leftLink) && isTerminating(rightLink)) {
    return new ApolloLink(function(operation) {
      return test(operation) ? leftLink.request(operation) || bundle_esm_default.of() : rightLink.request(operation) || bundle_esm_default.of();
    });
  } else {
    return new ApolloLink(function(operation, forward) {
      return test(operation) ? leftLink.request(operation, forward) || bundle_esm_default.of() : rightLink.request(operation, forward) || bundle_esm_default.of();
    });
  }
}
var concat = function(first, second) {
  var firstLink = toLink(first);
  if (isTerminating(firstLink)) {
    invariant.warn(new LinkError("You are calling concat on a terminating link, which will have no effect", firstLink));
    return firstLink;
  }
  var nextLink = toLink(second);
  if (isTerminating(nextLink)) {
    return new ApolloLink(function(operation) {
      return firstLink.request(operation, function(op) {
        return nextLink.request(op) || bundle_esm_default.of();
      }) || bundle_esm_default.of();
    });
  } else {
    return new ApolloLink(function(operation, forward) {
      return firstLink.request(operation, function(op) {
        return nextLink.request(op, forward) || bundle_esm_default.of();
      }) || bundle_esm_default.of();
    });
  }
};
var ApolloLink = function() {
  function ApolloLink2(request) {
    if (request)
      this.request = request;
  }
  ApolloLink2.prototype.split = function(test, left, right) {
    return this.concat(split(test, left, right || new ApolloLink2(passthrough)));
  };
  ApolloLink2.prototype.concat = function(next) {
    return concat(this, next);
  };
  ApolloLink2.prototype.request = function(operation, forward) {
    throw false ? new InvariantError(1) : new InvariantError("request is not implemented");
  };
  ApolloLink2.empty = empty;
  ApolloLink2.from = from;
  ApolloLink2.split = split;
  ApolloLink2.execute = execute;
  return ApolloLink2;
}();
function execute(link, operation) {
  return link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || bundle_esm_default.of();
}

// ../../node_modules/.pnpm/apollo-link-retry@2.2.16_graphql@15.3.0/node_modules/apollo-link-retry/lib/bundle.esm.js
function buildDelayFunction(delayOptions) {
  var _a3 = delayOptions || {}, _b = _a3.initial, initial = _b === void 0 ? 300 : _b, _c = _a3.jitter, jitter = _c === void 0 ? true : _c, _d = _a3.max, max = _d === void 0 ? Infinity : _d;
  var baseDelay = jitter ? initial : initial / 2;
  return function delayFunction(count) {
    var delay = Math.min(max, baseDelay * Math.pow(2, count));
    if (jitter) {
      delay = Math.random() * delay;
    }
    return delay;
  };
}
function buildRetryFunction(retryOptions) {
  var _a3 = retryOptions || {}, retryIf = _a3.retryIf, _b = _a3.max, max = _b === void 0 ? 5 : _b;
  return function retryFunction(count, operation, error) {
    if (count >= max)
      return false;
    return retryIf ? retryIf(error, operation) : !!error;
  };
}
var RetryableOperation = function() {
  function RetryableOperation2(operation, nextLink, delayFor, retryIf) {
    var _this = this;
    this.operation = operation;
    this.nextLink = nextLink;
    this.delayFor = delayFor;
    this.retryIf = retryIf;
    this.retryCount = 0;
    this.values = [];
    this.complete = false;
    this.canceled = false;
    this.observers = [];
    this.currentSubscription = null;
    this.onNext = function(value) {
      _this.values.push(value);
      for (var _i = 0, _a3 = _this.observers; _i < _a3.length; _i++) {
        var observer = _a3[_i];
        if (!observer)
          continue;
        observer.next(value);
      }
    };
    this.onComplete = function() {
      _this.complete = true;
      for (var _i = 0, _a3 = _this.observers; _i < _a3.length; _i++) {
        var observer = _a3[_i];
        if (!observer)
          continue;
        observer.complete();
      }
    };
    this.onError = function(error) {
      return __awaiter(_this, void 0, void 0, function() {
        var shouldRetry, _i, _a3, observer;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              this.retryCount += 1;
              return [4, this.retryIf(this.retryCount, this.operation, error)];
            case 1:
              shouldRetry = _b.sent();
              if (shouldRetry) {
                this.scheduleRetry(this.delayFor(this.retryCount, this.operation, error));
                return [2];
              }
              this.error = error;
              for (_i = 0, _a3 = this.observers; _i < _a3.length; _i++) {
                observer = _a3[_i];
                if (!observer)
                  continue;
                observer.error(error);
              }
              return [2];
          }
        });
      });
    };
  }
  RetryableOperation2.prototype.subscribe = function(observer) {
    if (this.canceled) {
      throw new Error("Subscribing to a retryable link that was canceled is not supported");
    }
    this.observers.push(observer);
    for (var _i = 0, _a3 = this.values; _i < _a3.length; _i++) {
      var value = _a3[_i];
      observer.next(value);
    }
    if (this.complete) {
      observer.complete();
    } else if (this.error) {
      observer.error(this.error);
    }
  };
  RetryableOperation2.prototype.unsubscribe = function(observer) {
    var index = this.observers.indexOf(observer);
    if (index < 0) {
      throw new Error("RetryLink BUG! Attempting to unsubscribe unknown observer!");
    }
    this.observers[index] = null;
    if (this.observers.every(function(o) {
      return o === null;
    })) {
      this.cancel();
    }
  };
  RetryableOperation2.prototype.start = function() {
    if (this.currentSubscription)
      return;
    this.try();
  };
  RetryableOperation2.prototype.cancel = function() {
    if (this.currentSubscription) {
      this.currentSubscription.unsubscribe();
    }
    clearTimeout(this.timerId);
    this.timerId = null;
    this.currentSubscription = null;
    this.canceled = true;
  };
  RetryableOperation2.prototype.try = function() {
    this.currentSubscription = this.nextLink(this.operation).subscribe({
      next: this.onNext,
      error: this.onError,
      complete: this.onComplete
    });
  };
  RetryableOperation2.prototype.scheduleRetry = function(delay) {
    var _this = this;
    if (this.timerId) {
      throw new Error("RetryLink BUG! Encountered overlapping retries");
    }
    this.timerId = setTimeout(function() {
      _this.timerId = null;
      _this.try();
    }, delay);
  };
  return RetryableOperation2;
}();
var RetryLink = function(_super) {
  __extends(RetryLink2, _super);
  function RetryLink2(options) {
    var _this = _super.call(this) || this;
    var _a3 = options || {}, attempts = _a3.attempts, delay = _a3.delay;
    _this.delayFor = typeof delay === "function" ? delay : buildDelayFunction(delay);
    _this.retryIf = typeof attempts === "function" ? attempts : buildRetryFunction(attempts);
    return _this;
  }
  RetryLink2.prototype.request = function(operation, nextLink) {
    var retryable = new RetryableOperation(operation, nextLink, this.delayFor, this.retryIf);
    retryable.start();
    return new bundle_esm_default(function(observer) {
      retryable.subscribe(observer);
      return function() {
        retryable.unsubscribe(observer);
      };
    });
  };
  return RetryLink2;
}(ApolloLink);
export {
  RetryLink
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=apollo-link-retry.js.map
